---
title: Recursion on Lists
---

Write the following functions using direct recursion. If no type
signature is given, also give the type of the function.

** ~product :: Num a => [a] -> a~

The product function computes the product of a finite list of numbers.

** ~concat~

Concatenate a list of lists into a single list

#+BEGIN_SRC haskell :solution
concat []       = []
concat (xs:xss) = xs ++ concat xss
#+END_SRC

** ~and :: [Bool] -> Bool~

and returns the conjunction of a Boolean list.

#+BEGIN_SRC haskell :solution
and []     = True
and (x:xs) = x && and xs
#+END_SRC

** ~or :: [Bool] -> Bool~

or returns the disjunction of a Boolean list.

** ~all~

Applied to a predicate and a list, all determines if all elements of
the list satisfy the predicate. For example,

- ~all even [1..5] == False~
- ~all even [2,4,6] == True~

#+BEGIN_SRC haskell :solution
all _ []     = True
all p (x:xs) = p x && all p xs
#+END_SRC

** ~map :: (a -> b) -> [a] -> [b]~

#+BEGIN_SRC haskell :solution
map _ []     = []
map f (x:xs) = f x : map f xs
#+END_SRC

** ~intersperse~

The intersperse function takes an element and a list and
`intersperses' that element between the elements of the list. For
example,

~intersperse ',' "abcde" == "a,b,c,d,e"~

** ~concatMap~

Map a function over a list and concatenate the results.

** ~unlines :: [String] -> String~

unlines is an inverse operation to lines. It joins lines, after
appending a terminating newline to each.


** ~filter :: (a -> Bool) -> [a] -> [a]~

filter, applied to a predicate and a list, returns the list of those
elements that satisfy the predicate; i.e.,

~filter p xs = [ x | x <- xs, p x]~

** ~partition~

The partition function takes a predicate a list and returns the pair
of lists of elements which do and do not satisfy the predicate,
respectively; i.e.,

~partition p xs == (filter p xs, filter (not . p) xs)~

#+BEGIN_SRC haskell :solution
partition _ []                 = ([],[])
partition p (x:xs) | p x       = let (ts,fs) = partition p xs in (x:ts,  fs)
                   | otherwise = let (ts,fs) = partition p xs in (  ts,x:fs)
#+END_SRC

** ~unzip :: [(a, b)] -> ([a], [b])~

unzip transforms a list of pairs into a list of first components and a
list of second components.

** ~insert :: Ord a => a -> [a] -> [a]~

The insert function takes an element and a (sorted) list and inserts
the element into the list at the last position where it is still less
than or equal to the next element.

#+BEGIN_SRC haskell :solution
insert q [] = [q]
insert q (x:xs) | q > x     = x : insert q xs
                | otherwise = q : x : xs
#+END_SRC

** ~sort :: Ord a => [a] -> [a]~

The sort function implements a sorting algorithm.

#+BEGIN_SRC haskell :solution
sort []     = []
sort (x:xs) = insert x (sort xs)
#+END_SRC

** ~take~

take i returns the first i elements from the input list. If the list
has fewer than i elements, the entire input list is returned.

#+BEGIN_SRC haskell :solution
take          :: Int -> [a] -> [a]
take 0 _      = []
take n []     = []
take n (x:xs) = x : take (n-1) xs
#+END_SRC

** ~takeWhile :: (a -> Bool) -> [a] -> [a]~

takeWhile, applied to a predicate p and a list xs, returns the longest
prefix (possibly empty) of xs of elements that satisfy p:

- ~takeWhile (< 3) [1,2,3,4,1,2,3,4] == [1,2]~
- ~takeWhile (< 9) [1,2,3] == [1,2,3]~
- ~takeWhile (< 0) [1,2,3] == []~

#+BEGIN_SRC haskell :solution
takeWhile _ []                 = []
takeWhile p (x:xs) | p x       = x : takeWhile p xs
                   | otherwise = []
#+END_SRC

** ~group~

The group function takes a list and returns a list of lists such that
the concatenation of the result is equal to the argument. Moreover,
each sublist in the result contains only equal elements. For example,

~group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]~

#+BEGIN_SRC haskell :solution
group []     = []
group (x:xs) = case group xs of
                 []                        -> [[x]]
                 (ys@(y:_):rs) | x == y    ->      (x:ys) : rs
                               | otherwise -> [x] :    ys : rs
#+END_SRC

**  ~remSuccessiveduplicates~

The function remSuccessiveDuplicates removes succesive repeated
elements from a list. For example

~remSuccessiveduplicates [1, 2, 2, 3, 2, 4] == [1, 2, 3, 2, 4]~

#+BEGIN_SRC haskell :solution
remSuccessiveduplicates []                   = []
remSuccessiveduplicates [x]                  = [x]
remSuccessiveduplicates (x:y:xs) | x == y    = remsuccessiveduplicates y ys
                                 | otherwise = x : remsuccessiveduplicates y ys
#+END_SRC

** ~nub~

The nub function removes duplicate elements from a list. In
particular, it keeps only the first occurrence of each element. (The
name nub means `essence'.)

#+BEGIN_SRC haskell :solution
nub [] = []
nub (x:xs) | x `elem` xs = nub xs
           | otherwise   = x : nub xs
#+END_SRC

** ~union :: Eq a => [a] -> [a] -> [a]~

The union function returns the list union of the two lists. For example,

~"dog" `union` "cow" == "dogcw"~

Duplicates, and elements of the first list, are removed from the the
second list, but if the first list contains duplicates, so will the
result.

**  ~intersect :: Eq a => [a] -> [a] -> [a]~

The intersect function takes the list intersection of two lists. For example,

~[1,2,3,4] `intersect` [2,4,6,8] == [2,4]~

If the first list contains duplicates, so will the result.

~[1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]~

** ~maybeLast :: [a] -> Maybe a~

Extract the last element of a list. Returns ~Nothing~ if the list is empty.

#+BEGIN_SRC haskell :solution
maybeLast []     = Nothing
maybeList (x:xs) = case maybeList xs of
                     Nothing -> Just x
                     jl      -> jl
#+END_SRC

** ~insertEverywhere~

insertEverywhere x ys "inserts" x at every position in the list ys. I.e.:

~insertEverywhere 10 [1..5] == [[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],[1,2,3,4,5,10]]~

#+BEGIN_SRC haskell :solution
insertEverywhere             :: a -> [a] -> [[a]]
insertEverywhere x []        = [[x]]
insertEverywhere x xs@(y:ys) = (x:xs) : map (y:) (insertEverywhere x ys)
#+END_SRC

**  ~permutations :: [a] -> [[a]]~

The permutations function returns the list of all permutations of the
argument. E.g.:

~permutations "abc" == ["abc","bac","bca","acb","cab","cba"]~

Note that it is ok if your solution returns the permutations in any
order. E.g.

~permutations "abc" == ["abc","bac","cba","bca","cab","acb"]~

is also correct.

#+BEGIN_SRC haskell :solution
permutations        :: [a] -> [[a]]
permutations []     = [[]]
permutations (x:xs) = concatMap (insertEverywhere x) $ permutations xs
#+END_SRC

** ~foldr :: (a -> b -> b) -> b -> [a] -> b~

The function foldr takes a function 'f' and an unit element 'z' and
"combines" all elements in the list using the function 'f', and
starting from value 'z'.

Your implementation should satisfy:

- ~foldr (+) 0 xs == sum xs~, for any list of numbers xs, and
- ~let f i s = chr i : s in foldr f "" [65..70] == "ABCDE"~

#+BEGIN_SRC haskell :solution
foldr _ z []     = z
foldr f z (x:xs) = f x (foldr f z xs)
#+END_SRC

** ~scanr :: (a -> b -> b) -> b -> [a] -> [b]~

scanr is similar to foldr but returns a list of successive reduced
values from the right:

~scanr f z [x_1, x_2, .., x_n] == [x_1 `f` .., .., x_(n-1) `f` z ,x_n `f` z,z]~

That is, it also returns all intermediate answers of a foldr. Note in
particular that

~head (scanr f z xs) == foldr f z xs~.

#+BEGIN_SRC haskell :solution
scanr _ z []     = [z]
scanr f z (x:xs) = let rs@(r:_) = scanr f z xs
                   in f x r : rs
#+END_SRC


** ~splitAll :: Int -> [a] -> [[a]]~

The splitAll function divides the given list in sublists, where the
sublists have the given length. Only the last list might be
shorter. For example,

~splitAll 3 [1..11] == [[1,2,3],[4,5,6],[7,8,9],[10,11]]~

*Hint*: Try to think of a simpler problem first, and write a helper
function that solves this simpler problem.

#+BEGIN_SRC haskell :solution
-- | splitAt splits off the first i elements. Returns all elements in
-- the first list if there are fewer than i elements.
splitAt          :: Int -> [a] -> ([a],[a])
splitAt 0 xs     = ([],xs)
splitAt i []     = ([],[])
splitAt i (x:xs) = let (ys,rest) = splitAt (i-1) xs
                   in (x:ys,rest)

splitAll      :: Int -> [a] -> [[a]]
splitAll i xs = case splitAt i xs of
                  (ys,[])   -> [ys]
                  (ys,rest) -> ys : splitAll i rest
#+END_SRC

** ~zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]~

zipWith combines two lists into a single list, by pairwise applying
the given function. I.e. if ~f~ is the supplied function, and ~x~ and
~y~ are the $i^\mathrm{th}$ elements in the first and second list,
respectively, the $^i\mathrm{th}$ element in the output list is ~f x
y~. If the lists have different length, the lengths are truncated to
the shortest list. For example:

- ~zipWith (,) [1,2,3,4] ["a","b","c","d","e"] == [(1,"a"),(2,"b"),(3,"c"),(4,"d")]~
- ~zipWith (+) [1,2,3] [100,200,300,400] == [1001,2002,3003]~

#+BEGIN_SRC haskell :solution
zipWith f (x:xs) (y:ys) = (f x y) : zipWith xs ys
zipWith _ _      _      = []
#+END_SRC

** ~transpose :: [[a]] -> [[a]]~

Transposes a matrix (represented by a list of equally long
lists). That is, the function ~transpose :: [[a]] -> [[a]]~ which maps
the $i^\mathrm{th}$ element of the $j^\mathrm{th}$ list to the
$j^\mathrm{th}$ element of the $i^\mathrm{th}$ list.

*Hint:* make use of the function ~zipWith~.

#+BEGIN_SRC haskell :solution
-- The main work is done here; we consider the first row separately,
-- transpose the rest of the matrix (without its first row), and then
-- cons the elements from the first row onto the result.
--
-- If there are no rows left we generate sufficiently many (infinitely
-- many) empty rows that this consing/combining described above is
-- successful. The zipWith function will just truncate the empty
-- leftover rows generated.
transpose' (xs:xss) = zipWith (:) xs (transpose' xss)
transpose' []       = repeat []

-- The above function transpose' transposes non-empty matrices. But
-- when the matrix empty at the very start we get this infinite list
-- of empty lists instead. We should fix that:
transpose [] = []
transpose xs = transpose' xs
#+END_SRC
