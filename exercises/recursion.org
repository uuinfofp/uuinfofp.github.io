#+TITLE: Direct Recursion Exercises

* Direct Recursion Exercises

Write the following functions using direct recursion

** ~(++) :: [a] -> [a] -> [a]~

Append two lists.

#+BEGIN_SRC haskell
[]     ++ ys = ys
(x:xs) ++ ys = x : xs ++ ys
#+END_SRC

** ~maybeLast :: [a] -> Maybe a~
Extract the last element of a list. Returns Nothing if the list is empty.

#+BEGIN_SRC haskell
maybeLast []     = Nothing
maybeList (x:xs) = case maybeList xs of
                     Nothing -> Just x
                     jl      -> jl
#+END_SRC

** ~length :: [a] -> Int~
length returns the length of a finite list as an Int.

#+BEGIN_SRC haskell
length []     = 0
length (_:xs) = 1 + length xs
#+END_SRC

** ~map :: (a -> b) -> [a] -> [b]~

#+BEGIN_SRC haskell
map _ []     = []
map f (x:xs) = f x : map f xs
#+END_SRC

** ~reverse :: [a] -> [a]~

reverse xs returns the elements of xs in reverse order. xs must be finite.

#+BEGIN_SRC haskell
reverse []     = []
reverse (x:xs) = reverse xs ++ [x]
#+END_SRC

** ~intersperse :: a -> [a] -> [a]~

The intersperse function takes an element and a list and `intersperses' that element between the elements of the list. For example,

 intersperse ',' "abcde" == "a,b,c,d,e"

** ~insertEverywhere :: ~a -> [a] -> [[a]]~

insertEverywhere x ys, inserts x at every position in ys. I.e.:

insertEverywhere 10 [1..5] ==
[[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],[1,2,3,4,5,10]]

#+BEGIN_SRC haskell
insertEverywhere             :: a -> [a] -> [[a]]
insertEverywhere x []        = [[x]]
insertEverywhere x xs@(y:ys) = (x:xs) : map (y:) (insertEverywhere x ys)
#+END_SRC

**  ~permutations :: [a] -> [[a]]~


The permutations function returns the list of all permutations of the
argument. E.g.:

permutations "abc" == ["abc","bac","bca","acb","cab","cba"]

Note that it is ok if your solution returns the permutations in any
order. E.g.

permutations "abc" == ["abc","bac","cba","bca","cab","acb"]

is also correct.

#+BEGIN_SRC haskell
permutations        :: [a] -> [[a]]
permutations []     = [[]]
permutations (x:xs) = concatMap (insertEverywhere x) $ permutations xs
#+END_SRC

** ~concat :: [[a]] -> [a]~

Concatenate a list of lists.

#+BEGIN_SRC haskell
concat []       = []
concat (xs:xss) = xs ++ concat xss
#+END_SRC

** ~concatMap :: (a -> [b]) -> [a] -> [b]~

Map a function over a list and concatenate the results.

** ~and :: [Bool] -> Bool~

and returns the conjunction of a Boolean list. For the result to be
True, the list must be finite; False, however, results from a False
value at a finite index of a finite or infinite list.

#+BEGIN_SRC haskell
and []     = True
and (x:xs) = x && and xs
#+END_SRC

** ~or :: [Bool] -> Bool~

or returns the disjunction of a Boolean list. For the result to be
False, the list must be finite; True, however, results from a True
value at a finite index of a finite or infinite list.

** ~all :: (a -> Bool) -> [a] -> Bool~

Applied to a predicate and a list, all determines if all elements of the list satisfy the predicate. For the result to be True, the list must be finite; False, however, results from a False value for the predicate applied to an element at a finite index of a finite or infinite list.

#+BEGIN_SRC haskell
all _ []     = True
all p (x:xs) = p x && all p xs
#+END_SRC

** ~any :: (a -> Bool) -> [a] -> Bool~

Applied to a predicate and a list, any determines if any element of
the list satisfies the predicate. For the result to be False, the list
must be finite; True, however, results from a True value for the
predicate applied to an element at a finite index of a finite or
infinite list.

** ~sum :: Num a => [a] -> a~

The sum function computes the sum of a finite list of numbers.

** ~product :: Num a => [a] -> a~

The product function computes the product of a finite list of numbers.

** ~scanr :: (a -> b -> b) -> b -> [a] -> [b]~

scanr is similar to foldr but returns a list of successive reduced
values from the right:

 scanr g z [x_1, x_2, .., x_n] == [x_1 `g` .., .., x_(n-1) `g` z ,x_n `g` z,z]

(i.e., it also returns all intermediate answers of a foldr). Note that

 head (scanr f z xs) == foldr f z xs.

#+BEGIN_SRC haskell
scanr _ z []     = [z]
scanr g z (x:xs) = let rs@(r:_) = scanr g z xs
                   in g x r : rs
#+END_SRC

** ~takeWhile :: (a -> Bool) -> [a] -> [a]~

takeWhile, applied to a predicate p and a list xs, returns the longest
prefix (possibly empty) of xs of elements that satisfy p:

 takeWhile (< 3) [1,2,3,4,1,2,3,4] == [1,2]
 takeWhile (< 9) [1,2,3] == [1,2,3]
 takeWhile (< 0) [1,2,3] == []

#+BEGIN_SRC haskell
takeWhile _ []                 = []
takeWhile p (x:xs) | p x       = x : takeWhile p xs
                   | otherwise = []
#+END_SRC

** ~group :: Eq a => [a] -> [[a]]~

The group function takes a list and returns a list of lists such that
the concatenation of the result is equal to the argument. Moreover,
each sublist in the result contains only equal elements. For example,

 group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]

#+BEGIN_SRC haskell
group []     = []
group (x:xs) = case group xs of
                 []                        -> [[x]]
                 (ys@(y:_):rs) | x == y    ->      (x:ys) : rs
                               | otherwise -> [x] :    ys : rs
#+END_SRC

** ~tails :: [a] -> [[a]]~


The tails function returns all final segments of the argument, longest first. For example,

 tails "abc" == ["abc", "bc", "c",""]

** ~elem :: Eq a => a -> [a] -> Bool~

elem is the list membership predicate, usually written in infix form, e.g., x `elem` xs. For the result to be False, the list must be finite; True, however, results from an element equal to x found at a finite index of a finite or infinite list.

** ~lookup :: Eq a => a -> [(a, b)] -> Maybe b~

lookup key assocs looks up a key in an association list.
Searching with a predicate

#+BEGIN_SRC haskell
lookup q []                 = Nothing
lookup q (x:xs) | q == x    = Just x
                | otherwise = lookup q xs
#+END_SRC

** ~find :: (a -> Bool) -> [a] -> Maybe a~

The find function takes a predicate and a list and returns the first
element in the list matching the predicate, or Nothing if there is no
such element.

** ~filter :: (a -> Bool) -> [a] -> [a]~

filter, applied to a predicate and a list, returns the list of those
elements that satisfy the predicate; i.e.,

 filter p xs = [ x | x <- xs, p x]

** ~partition :: (a -> Bool) -> [a] -> ([a], [a])~

The partition function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,

 partition p xs == (filter p xs, filter (not . p) xs)

#+BEGIN_SRC haskell
partition _ []                 = ([],[])
partition p (x:xs) | p x       = let (ts,fs) = partition p xs in (x:ts,  fs)
                   | otherwise = let (ts,fs) = partition p xs in (  ts,x:fs)
#+END_SRC

** ~unzip :: [(a, b)] -> ([a], [b])~

unzip transforms a list of pairs into a list of first components and a
list of second components.

** ~unlines :: [String] -> String~

unlines is an inverse operation to lines. It joins lines, after
appending a terminating newline to each.

** ~nub :: Eq a => [a] -> [a]~

The nub function removes duplicate elements from a list. In
particular, it keeps only the first occurrence of each element. (The
name nub means `essence'.)

** ~union :: Eq a => [a] -> [a] -> [a]~

The union function returns the list union of the two lists. For example,

 "dog" `union` "cow" == "dogcw"

Duplicates, and elements of the first list, are removed from the the
second list, but if the first list contains duplicates, so will the
result.

**  ~intersect :: Eq a => [a] -> [a] -> [a]~

The intersect function takes the list intersection of two lists. For example,

 [1,2,3,4] `intersect` [2,4,6,8] == [2,4]

If the first list contains duplicates, so will the result.

 [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]

** ~insert :: Ord a => a -> [a] -> [a]~

The insert function takes an element and a (sorted) list and inserts
the element into the list at the last position where it is still less
than or equal to the next element.

#+BEGIN_SRC haskell
insert q [] = [q]
insert q (x:xs) | q > x     = x : insert q xs
                | otherwise = q : x : xs
#+END_SRC

** ~sort :: Ord a => [a] -> [a]~

The sort function implements a (stable) sorting algorithm.

#+BEGIN_SRC haskell
sort []     = []
sort (x:xs) = insert x (sort xs)
#+END_SRC
