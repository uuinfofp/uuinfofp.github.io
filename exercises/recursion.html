<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Functional Programming - Recursion on Lists</title>
    <link rel="stylesheet" href="../css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrapify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
  </head>
  <body>
    <!-- Static navbar -->
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">Functional Programming</a> <!--  -->
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <!-- <li><a href="/description.html">Description</a></li> -->
            <li><a href="../lectures.html">Lectures</a></li>
            <li><a href="../labs.html">Practicals</a></li>
            <li><a href="../exercises.html">Exercises</a></li>
            <li><a href="../optional.html">Optional Assignment</a></li>
            <li><a href="../exams.html">Old Exams</a></li>
            <!-- <li><a href="projects.html">Projects</a></li> -->
            <li><a target="_blank" href="https://cursusplanner.uu.nl/course/INFOFP/2025/1">Education page</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container" id="main">
      <h2>Recursion on Lists</h2>

      <p>Implement the following functions using direct recursion. If no type
signature is given, also give the type of the function. Note that
these functions are actually all available in the standard library in
the module <code>Data.List</code>.</p>
<h1 data-number="1" id="section-1"><span class="header-section-number">1</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>product :: Num a =&gt; [a] -&gt; a</code></p>
<p>The function computes the product of a finite list of numbers.</p>
<h1 data-number="2" id="section-2"><span class="header-section-number">2</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>concat</code></p>
<p>Concatenate a list of lists into a single list</p>
<h1 data-number="3" id="section-3"><span class="header-section-number">3</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>and :: [Bool] -&gt; Bool</code></p>
<p>and returns the conjunction of a Boolean list.</p>
<h1 data-number="4" id="section-4"><span class="header-section-number">4</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>or :: [Bool] -&gt; Bool</code></p>
<p>or returns the disjunction of a Boolean list.</p>
<h1 data-number="5" id="section-5"><span class="header-section-number">5</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>all</code></p>
<p>Applied to a predicate and a list, all determines if all elements of
the list satisfy the predicate. For example,</p>
<ul>
<li><code>all even [1..5] == False</code></li>
<li><code>all even [2,4,6] == True</code></li>
</ul>
<h1 data-number="6" id="section-6"><span class="header-section-number">6</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></p>
<h1 data-number="7" id="section-7"><span class="header-section-number">7</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>intersperse</code></p>
<p>The intersperse function takes an element and a list and
`intersperses’ that element between the elements of the list. For
example,</p>
<p><code>intersperse ',' "abcde" == "a,b,c,d,e"</code></p>
<h1 data-number="8" id="section-8"><span class="header-section-number">8</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>concatMap</code></p>
<p>Map a function over a list and concatenate the results.</p>
<h1 data-number="9" id="section-9"><span class="header-section-number">9</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>unlines :: [String] -&gt; String</code></p>
<p>unlines is an inverse operation to lines. It joins lines, after
appending a terminating newline to each.</p>
<h1 data-number="10" id="section-10"><span class="header-section-number">10</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
<p>filter, applied to a predicate and a list, returns the list of those
elements that satisfy the predicate; i.e.,</p>
<p><code>filter p xs = [ x | x &lt;- xs, p x]</code></p>
<h1 data-number="11" id="section-11"><span class="header-section-number">11</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>partition</code></p>
<p>The partition function takes a predicate a list and returns the pair
of lists of elements which do and do not satisfy the predicate,
respectively; i.e.,</p>
<p><code>partition p xs == (filter p xs, filter (not . p) xs)</code></p>
<h1 data-number="12" id="section-12"><span class="header-section-number">12</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>unzip :: [(a, b)] -&gt; ([a], [b])</code></p>
<p>unzip transforms a list of pairs into a list of first components and a
list of second components.</p>
<h1 data-number="13" id="section-13"><span class="header-section-number">13</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code></p>
<p>The insert function takes an element and a (sorted) list and inserts
the element into the list at the last position where it is still less
than or equal to the next element.</p>
<h1 data-number="14" id="section-14"><span class="header-section-number">14</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
<p>The sort function implements a sorting algorithm.</p>
<h1 data-number="15" id="section-15"><span class="header-section-number">15</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>take</code></p>
<p>take i returns the first i elements from the input list. If the list
has fewer than i elements, the entire input list is returned.</p>
<h1 data-number="16" id="section-16"><span class="header-section-number">16</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
<p>takeWhile, applied to a predicate p and a list xs, returns the longest
prefix (possibly empty) of xs of elements that satisfy p:</p>
<ul>
<li><code>takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]</code></li>
<li><code>takeWhile (&lt; 9) [1,2,3] == [1,2,3]</code></li>
<li><code>takeWhile (&lt; 0) [1,2,3] == []</code></li>
</ul>
<h1 data-number="17" id="section-17"><span class="header-section-number">17</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>group</code></p>
<p>The group function takes a list and returns a list of lists such that
the concatenation of the result is equal to the argument. Moreover,
each sublist in the result contains only equal elements. For example,</p>
<p><code>group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</code></p>
<h1 data-number="18" id="section-18"><span class="header-section-number">18</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>remSuccessiveduplicates</code></p>
<p>The function remSuccessiveDuplicates removes succesive repeated
elements from a list. For example</p>
<p><code>remSuccessiveduplicates [1, 2, 2, 3, 2, 4] == [1, 2, 3, 2, 4]</code></p>
<h1 data-number="19" id="section-19"><span class="header-section-number">19</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>nub</code></p>
<p>The nub function removes duplicate elements from a list. In
particular, it keeps only the first occurrence of each element. (The
name nub means `essence’.)</p>
<h1 data-number="20" id="section-20"><span class="header-section-number">20</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>union :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]</code></p>
<p>The union function returns the list union of the two lists. For example,</p>
<p><code>"dog" `union` "cow" == "dogcw"</code></p>
<p>Duplicates, and elements of the first list, are removed from the the
second list, but if the first list contains duplicates, so will the
result.</p>
<h1 data-number="21" id="section-21"><span class="header-section-number">21</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>intersect :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]</code></p>
<p>The intersect function takes the list intersection of two lists. For example,</p>
<p><code>[1,2,3,4] `intersect` [2,4,6,8] == [2,4]</code></p>
<p>If the first list contains duplicates, so will the result.</p>
<p><code>[1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]</code></p>
<h1 data-number="22" id="section-22"><span class="header-section-number">22</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>maybeLast :: [a] -&gt; Maybe a</code></p>
<p>Extract the last element of a list. Returns <code>Nothing</code> if the list is empty.</p>
<h1 data-number="23" id="section-23"><span class="header-section-number">23</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>insertEverywhere</code></p>
<p>insertEverywhere x ys “inserts” x at every position in the list ys. I.e.:</p>
<p><code>insertEverywhere 10 [1..5] == [[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],[1,2,3,4,5,10]]</code></p>
<h1 data-number="24" id="section-24"><span class="header-section-number">24</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>permutations :: [a] -&gt; [[a]]</code></p>
<p>The permutations function returns the list of all permutations of the
argument. E.g.:</p>
<p><code>permutations "abc" == ["abc","bac","bca","acb","cab","cba"]</code></p>
<p>Note that it is ok if your solution returns the permutations in any
order. E.g.</p>
<p><code>permutations "abc" == ["abc","bac","cba","bca","cab","acb"]</code></p>
<p>is also correct.</p>
<h1 data-number="25" id="section-25"><span class="header-section-number">25</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></p>
<p>The function foldr takes a function ‘f’ and an unit element ‘z’ and
“combines” all elements in the list using the function ‘f’, and
starting from value ‘z’.</p>
<p>Your implementation should satisfy:</p>
<ul>
<li><code>foldr (+) 0 xs == sum xs</code>, for any list of numbers xs, and</li>
<li><code>let f i s = chr i : s in foldr f "" [65..70] == "ABCDE"</code></li>
</ul>
<h1 data-number="26" id="section-26"><span class="header-section-number">26</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>scanr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</code></p>
<p>scanr is similar to foldr but returns a list of successive reduced
values from the right:</p>
<p><code>scanr f z [x_1, x_2, .., x_n] == [x_1 `f` .., .., x_(n-1) `f` z ,x_n `f` z,z]</code></p>
<p>That is, it also returns all intermediate answers of a foldr. Note in
particular that</p>
<p><code>head (scanr f z xs) == foldr f z xs</code>.</p>
<h1 data-number="27" id="section-27"><span class="header-section-number">27</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>run length encoding: <code>encode</code></p>
<p>The function <code>encode</code> computes the run-length encoding of a list.
That is, the list is mapped to a list of pairs whose first element
says how many times the second component of the pair appears in
adjacent positions in the list. For example:</p>
<p><code>encode [1, 2, 2, 3, 2, 4]  == [(1, 1),(2, 2),(1, 3),(1, 2),(1, 4)]</code></p>
<h1 data-number="28" id="section-28"><span class="header-section-number">28</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>run length encoding: <code>decode</code></p>
<p>Given a run length encoded list, <code>decode</code> produces the original input
list, e.g. from the example above:</p>
<p><code>decode [(1, 1),(2, 2),(1, 3),(1, 2),(1, 4)] == [1, 2, 2, 3, 2, 4]</code></p>
<h1 data-number="29" id="section-29"><span class="header-section-number">29</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>splitAll :: Int -&gt; [a] -&gt; [[a]]</code></p>
<p>The splitAll function divides the given list in sublists, where the
sublists have the given length. Only the last list might be
shorter. For example,</p>
<p><code>splitAll 3 [1..11] == [[1,2,3],[4,5,6],[7,8,9],[10,11]]</code></p>
<p><strong>Hint</strong>: Try to think of a simpler problem first, and write a helper
function that solves this simpler problem.</p>
<h1 data-number="30" id="section-30"><span class="header-section-number">30</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>
<p>zipWith combines two lists into a single list, by pairwise applying
the given function. I.e. if <code>f</code> is the supplied function, and <code>x</code> and
<code>y</code> are the <span class="math inline">\(i^\mathrm{th}\)</span> elements in the first and second list,
respectively, the <span class="math inline">\(^i\mathrm{th}\)</span> element in the output list is <code>f x y</code>. If the lists have different length, the lengths are truncated to
the shortest list. For example:</p>
<ul>
<li><code>zipWith (,) [1,2,3,4] ["a","b","c","d","e"] == [(1,"a"),(2,"b"),(3,"c"),(4,"d")]</code></li>
<li><code>zipWith (+) [1,2,3] [100,200,300,400] == [1001,2002,3003]</code></li>
</ul>
<h1 data-number="31" id="section-31"><span class="header-section-number">31</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>transpose :: [[a]] -&gt; [[a]]</code></p>
<p>Transposes a matrix (represented by a list of equally long
lists). That is, the function <code>transpose :: [[a]] -&gt; [[a]]</code> which maps
the <span class="math inline">\(i^\mathrm{th}\)</span> element of the <span class="math inline">\(j^\mathrm{th}\)</span> list to the
<span class="math inline">\(j^\mathrm{th}\)</span> element of the <span class="math inline">\(i^\mathrm{th}\)</span> list.</p>
<p><strong>Hint:</strong> make use of the function <code>zipWith</code>.</p>
<h1 data-number="32" id="maximum-segment-sum"><span class="header-section-number">32</span> Maximum Segment Sum <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p>Given a list of numbers, we define a <em>segment</em> as a contiguous
sublist. For example <code>[2,3,4]</code> is a segment of <code>l=[1,2,3,4,5,6]</code> but
<code>[2,4,6]</code> is not a segment of <code>l</code>. The sum of a segment is the value
we obtain by summing all values in a segment, and the <em>maximum segment
sum</em> of <code>l</code> is the maximum sum over all possible segments of <code>l</code>.</p>
<ol type="1">
<li><p>Write the function <code>segments</code> that computes all segments of a list
by combine existing functions from Data.List (which you have
re-implemented in the exercises above)</p></li>
<li><p>implement <code>maximumSegmentSum</code> using a combination of existing List functions.</p></li>
<li><p>The above implementation is simple, but actually very slow
(<span class="math inline">\(O(n^3)\)</span> time). With a bit of work we can derive a linear time
implementation instead!</p>
<p>Write, using direct recursion, a function <code>maxPrefixSum</code> that
computes the maximum among all prefixes of a list.</p></li>
<li><p>Implement a function <code>maximumSegSum</code> with direct recursion.</p></li>
<li><p>Hopefully you can notice some commonality in the implementation of
<code>maxPrefixSum</code> and <code>maxSegSum</code>. Exploit that to obtain a linear
time implementation <code>maxSegSum</code> for the maximum segment sum.</p>
<p>Hint: Write a function <code>maxPrefixAndSegSum : [Int] -&gt; (Int,Int)</code> that
<em>simultaneously</em> computes the maximum prefix sum and the maximum
segment sum. I.e. Your function should satisfy the specification:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>maxPrefixAndSegSum xs <span class="ot">=</span> (maxPrefixSum xs, maxSegSum xs)</span></code></pre></div></li>
</ol>
<h1 data-number="33" id="section-32"><span class="header-section-number">33</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>Let <code>countTrues :: [Bool] -&gt; [int]</code> be a function such that <code>countTrues bs</code> computes, for
each prefix of the list <code>bs</code>, the number of <code>True</code> s in the list.</p>
<ol type="1">
<li><p>Write <code>countTrues</code> using direct recursion.</p>
<p>Hint: Take another look at your implementation of <code>inits</code> first.</p></li>
<li><p>Write <code>countTrues</code> using a combination of existing functions.</p></li>
<li><p>Write <code>countTrues</code> using an accumulator so that your
implementation runs in linear time.</p></li>
<li><p>Write an alternative implementation of <code>countTrues</code> (not using an
accumulator) that also runs in linear time.</p></li>
</ol>
    </div>
  </body>
</html>
