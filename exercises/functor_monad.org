---
title: Functors, monads, applicatives and traversables
---

1. Show that the definition of the arithmetic evaluator using ~next~ in Lecture 13 is the same as the one using nested ~case~ clauses by expanding the definition of the former.

2. Define a function ~tuple :: Monad m => m a -> m b -> m (a, b)~
     using explicit ~(>>=)~, ~do~-notation and applicative operators.
    - What does the function do for the ~Maybe~ monad?

    #+BEGIN_SRC haskell :solution
    tuple           :: Monad m => m a -> m b -> m (a,b)
    tuple actA actB = actA >>= \a ->
                        actB >>= \b -> return (a,b)


    tuple           :: Monad m => m a -> m b -> m (a,b)
    tuple actA actB = do a <- actA
                         b <- actB
                         return (a,b)

    tuple           :: Monad m => m a -> m b -> m (a,b)
    tuple actA actB = (,) <$> actA <*> actB
    #+END_SRC


3. Define the following set of actions for ~State s a~ :
    - A computation ~get~ of type ~State s s~ that obtains the current value of the state.
    - A function ~modify~ of type ~(s -> s) -> State s ()~ that updates the current state using the given function.
    - A function ~put~ of type ~s -> State s ()~ that overwrites the current state with the given value.

    Using those primitive operations:
    * Define ~modify~ using ~get~ and ~put~.
    * Define ~put~ using ~modify~.

    #+BEGIN_SRC haskell :solution
    modify f = do x <- get
                  put $ f x

    put x = modify (const x)
    #+END_SRC


4. Explain the behavior of ~sequence~ for the ~Maybe~ monad.

5. Define a monadic generalisation of ~foldl~:

    #+BEGIN_SRC haskell
    foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
    #+END_SRC

    #+BEGIN_SRC haskell :solution
    foldM f v = foldl' g (return v)
      where
        g r x = r >>= \a -> f a x
    #+END_SRC


6. Show that the ~Maybe~ monad satisfies the monad laws.

7. Given the type:

    #+BEGIN_SRC haskell
    data Expr a = Var a | Val Int | Add (Expr a) (Expr a)
    #+END_SRC

    of expressions built from variables of type ~a~, show that this
   type is monadic by completing the following declaration:

    #+BEGIN_SRC haskell
    instance Monad Expr where
      -- return :: a -> Expr a
      return x = ...

      -- (>>=) :: Expr a -> (a -> Expr b) -> Expr b
      (Var a)   >>= f = ...
      (Val n)   >>= f = ...
      (Add x y) >>= f = ...
    #+END_SRC

    With the aid of an example, explain what the ~(>>=)~ operator for this type does.
