---
title: Data Types and Typeclasses
---

** Natural numbers

Consider the set of natural numbers $\mathbb{N}$, and observe that:

- zero is a natural number, and
- any other natural number is the successor of some other natural
  number.

1. Define a data type ~Nat~ representing natural numbers using the
   above observation.

   #+BEGIN_SRC haskell :solution
   data Nat = Zero | Succ Nat
   #+END_SRC

2. Write functions ~toInt :: Nat -> Int~ and ~fromInt :: Int -> Nat~
     that allows you to convert between ~Nat~ and ~Int~.

   #+BEGIN_SRC haskell :solution
   toInt Zero     = 0
   toInt (Succ n) = 1 + toInt n

   fromInt i = case i `compare` 0 of
                 LT -> error "negative number!"
                 EQ -> Zero
                 GT -> Succ (fromInt $ i-1)
   #+END_SRC

** ~<~

Give a direct definition of the ~<~ operator on lists. This definition
should not use operators like ~<=~ for lists.

When trying out this definition using ~ghci~, do not use the ~<~
symbol, since it is already defined in the ~Prelude~.

#+BEGIN_SRC haskell :solution
(<)         :: Ord a => [a] -> [a] -> Bool
[]     < []     = False
[]     < _      = True
(_:_)  < []     = False
(x:xs) < (y:ys) = x < y && xs < ys
#+END_SRC

** Complex numbers

1. Write a data type ~Complex~ to represent complex numbers of the form
   $a + b*i$.

   #+BEGIN_SRC haskell :solution
   data Complex = C Float Float
   #+END_SRC

2. Make ~Complex~ an instance of ~Show~, ~Eq~, and ~Num~ (write the
   instances explicitly rather than deriving them).

   #+BEGIN_SRC haskell :solution
   instance Num Complex where
     (C a b) + (C x y) = C (a + x)    (b + y)
     (C a b) - (C x y) = C (a - x)    (b - y)
     (C a b) * (C x y) = C (a*x-b*y)  (a*y+b*x)
     negate (C a b)    = C (negate a) (negate b)
     abs    (C a b)    = C (a*a+b*b)  0
     fromInteger i     = C (fromInteger i) 0
   #+END_SRC

** Bikes

1. Define data types that model the following situation as precisely
   as possible:

    #+BEGIN_QUOTE
    A bikeshop sells three kinds of bikes: city bikes, road bikes and
    mountainbikes, in three different sizes. In most cases, bike sizes are
    standardized into (small, medium, and large), however it is also
    possible for bikes to have a custom (integral) size (the size of the
    frame in inches). The mountainbikes and road bikes have gears. They
    have a cassette with many cogs on the rear wheel, and some of them may
    have a second chainring in the front (doubling the number of available
    gears). City bikes do not have gears. However, unlike the other types
    of bikes they have fenders either in the front, the back, or on both
    wheels). Fenders themselves come in two types; they are either made
    from plastic or metal.
    #+END_QUOTE

    #+BEGIN_SRC haskell :solution
    -- some variations are possible, but the following answer captures the
    -- situation fairly precisely:

    data StandardSize = Small | Medium | Large
    data BikeSize = Standardized StandardSize | CustomSize Int

    data FrontChainrings = SingleChainring | TwoChainRings

    data Gears = Gears FrontChainrings Int

    data Fender = PlasticFender | MetalFender

    data Bike = CityBike (Maybe Fender) (Maybe Fender)
              | RoadBike Gears
              | MTB Gears

    data Bikeshop = Bikeshop [Bike]
    #+END_SRC

2. Consider a function ~getFenders~ that returns the fenders of a bike,
   if it has any. What would be a good type for this function?

   #+BEGIN_SRC haskell :solution
   getFenders :: Bike -> (Maybe Fender, Maybe Fender)

   -- or potentially one could even define a custom return type:
   data Fenders = Fenders { frontFender :: Maybe Fender
                          , backFender  :: Maybe Fender
                          }
   #+END_SRC

3. Write the function ~getFenders~

4. Write a function ~byGears~ that lists all bikes available in the
   bikeshop, ordered by number of gears.

** ~Set a~

1. Define a type ~Set a~ which consists of elements of type ~a~, and define a
function ~subset :: Eq a => Set a -> Set a -> Bool~ which checks
whether all the elements in the first set also belong to the
second.

2. Use the ~subset~ function above to define an ~Eq~ instance for ~Set
   a~.

3. Why do we have to define ~Set a~ as its own data type, instead of an
alias over ~[a]~?

** ~Finite~

Define a class ~Finite~. This class has only one method: the list of
all the elements of that type. The idea is that such list is finite,
hence the name. Define the following instances for ~Finite~:

    - ~Bool~.
    - ~Char~.
    - ~(a, b)~ for finite ~a~ and ~b~.
    - ~Set a~, as defined in the previous exercise, when ~a~ is finite.
    - ~a -> b~ whenever ~a~ and ~b~ are finite and ~a~ supports
      equality. Use this to make ~a -> b~ an instance of ~Eq~.

#+BEGIN_SRC haskell :solution
class Finite a where
  elements :: [a]

instance Finite Bool where
  elements = [False, True]

instance (Finite a, Finite b) => Finite (a, b) where
  elements = [(x, y) | x <- elements, y <- elements]

-- Auxiliary definition for Finite (Set a)
-- Computes all subsets for the given elements,
-- that is, all combinations where each element
-- in the list may or may not appear
allSubsets :: [a] -> [Set a]
allSubsets []     = [[]]
allSubsets (v:vs) = let ss = allSubsets vs
                     in ss ++ [v:s | s <- ss]

instance Finite a => Finite (Set a) where
  elements = allSubsets elements

-- Auxiliary definition for Finite (a -> b)
-- Computes all key-value pairs from two lists,
-- the first one gives the keys and the second
-- one gives the possible values
allKVPairs :: [k] -> [v] -> [[(k, v)]]
allKVPairs []     _  = [[]]
allKVPairs (k:ks) vs = [(k,v):kvs
                         | kvs <- allKVPairs ks vs
                         , v   <- vs]

instance (Finite a, Finite b, Eq a) => Finite (a -> b) where
  elements = [\k -> fromJust (lookup k kv)
               | kv <- allKVPairs elements elements]
#+END_SRC
