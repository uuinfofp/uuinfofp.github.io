---
title: Higher order Functions
---

Recommended: Currying, Filter


** Parentheses!?
Give examples for functions with the following types:

#+BEGIN_SRC haskell
(Float −> Float) −> Float
Float −> (Float −> Float)
(Float −> Float) −> (Float −> Float)
#+END_SRC

#+BEGIN_SRC haskell  :solution
-- For example (all these expressions have more general polymorphic types, but, in particular, type check at the requested types)
\f -> f 2.0 :: (Float −> Float) −> Float 
(*) :: Float −> (Float −> Float)
(.) (+1) :: (Float −> Float) −> (Float −> Float) 
#+END_SRC

Give an example program ~p~ with the following type and explain how the function arrow ~->~ associates:
#+BEGIN_SRC haskell
p :: Int -> Bool -> Int
#+END_SRC
#+BEGIN_SRC haskell  :solution
-- For example
p i b = if b then i else -i
-- Indeed, the function arrow -> always associates to the right, so this type should be read as 
-- the type Int -> (Bool -> Int) of curried multiple argument functions, rather than the type (Int -> Bool) -> Int of higher order functions
#+END_SRC

Give examples of programs ~foo~, ~bar~ and ~baz~, such that ~foo bar baz~ type checks and please explain how function application associates.
#+BEGIN_SRC haskell  :solution
-- For example,
foo :: Int -> Int -> Int
foo = (+)
bar :: Int 
bar = 1
baz :: Int
baz = 2
-- Then foo bar baz is well-typed at type Int 
-- Indeed, function application always associates to the left so the expression should be read as (foo bar) baz
-- Another example would be 
foo :: (a -> [a] -> [a]) -> [a] -> [a] -> [a]
foo = foldr 
bar :: a -> [a] -> [a]
bar a as = as ++ [a] 
baz :: [a] 
baz = []
-- Then, foo bar baz (which should be read as (foo bar) baz) has type [a]
-- Note that function application associating to the left and function arrows associating to the right are nice behaviour because it means 
-- that we can implement the default use-case of curried functions of multiple arguments and partial application of such functions without writing many parentheses in either the type or the program.
#+END_SRC
Can you give examples of programs ~foo~, ~bar~ and ~baz~, such that one might expect ~foo bar baz~ to be well-typed if function application were to associate in the opposite direction, but such 
that ~foo bar baz~ is in reality ill-typed?
#+BEGIN_SRC haskell  :solution
-- For example,
foo :: Bool -> Bool
foo = not
bar :: Bool -> Bool 
bar = not
baz :: Bool
baz = True
-- Then foo (bar baz) is well-typed at type Bool
-- However, as function application associates to the left in reality and not to the right, foo bar baz should be parsed as (not not) True, which does not type check.
#+END_SRC



** Currying
Please implement two functions

#+BEGIN_SRC haskell
curry :: ((a, b) -> c) -> (a -> b -> c)
uncurry :: (a -> b -> c) -> ((a, b) -> c)
#+END_SRC

#+BEGIN_SRC haskell :solution
curry f a b = f (a, b)
uncurry g (a, b) = g a b
#+END_SRC

Can you convince yourself that ~curry~ and ~uncurry~ are mutually inverse? Try it out on some example functions!

Please simplify the types of ~curry~ and ~uncurry~ by removing unnecessary parentheses
#+BEGIN_SRC haskell :solution
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
#+END_SRC



** Filter
The function ~filter~ can be defined in terms of ~concat~ and ~map~:

#+BEGIN_SRC haskell
    filter p = concat . map box
      where box x = _
#+END_SRC

Complete the definition of ~box~.

#+BEGIN_SRC haskell :solution
box x = if p x then [x] else []
#+END_SRC


** Function Composition

Function composition first applies the latter of the supplied
functions to the argument, the former thereafter. Write a function
~before~ that can be used to rewrite ~f . g . h~ to ~h `before` g
`before` f~. What can you say about associativity of ~(.)~ and
~before~?

#+BEGIN_SRC haskell :solution
before :: (a -> b) -> (b -> c) -> (a -> c)
before = flip (.)
-- both (.) and before are associative operations
#+END_SRC

** Higher order data types

We have seen that ~[...]~ is a type function that maps types to
types. Similarly because ~−>~ is a type constructor mapping two types
to a type, for some ~c~ also ~c −>~ is a type function mapping a type
~a~ to ~c −> a~. Rewrite the type of ~map~ by substituting the type
function ~[...]~ by ~c −>~. Can you derive an implementation from the
resulting type?

#+BEGIN_SRC haskell :solution
mapFun :: (a -> b) -> (c -> a) -> (c -> b)
mapFun = (.)
#+END_SRC
