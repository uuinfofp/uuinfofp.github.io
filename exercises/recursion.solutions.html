<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Functional Programming - Recursion on Lists</title>
    <link rel="stylesheet" href="../css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrapify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
  </head>
  <body>
    <!-- Static navbar -->
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">Functional Programming</a> <!--  -->
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <!-- <li><a href="/description.html">Description</a></li> -->
            <li><a href="../lectures.html">Lectures</a></li>
            <li><a href="../labs.html">Practicals</a></li>
            <li><a href="../exercises.html">Exercises</a></li>
            <li><a href="../optional.html">Optional Assignment</a></li>
            <li><a href="../exams.html">Old Exams</a></li>
            <!-- <li><a href="projects.html">Projects</a></li> -->
            <li><a target="_blank" href="https://cursusplanner.uu.nl/course/INFOFP/2025/1">Education page</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container" id="main">
      <h2>Recursion on Lists</h2>

      <p>Implement the following functions using direct recursion. If no type
signature is given, also give the type of the function. Note that
these functions are actually all available in the standard library in
the module <code>Data.List</code>.</p>
<h1 data-number="1" id="section-1"><span class="header-section-number">1</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>product :: Num a =&gt; [a] -&gt; a</code></p>
<p>The function computes the product of a finite list of numbers.</p>
<h1 data-number="2" id="section-2"><span class="header-section-number">2</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>concat</code></p>
<p>Concatenate a list of lists into a single list</p>
<div class="sourceCode" id="cb1" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> []       <span class="ot">=</span> []</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> (xs<span class="op">:</span>xss) <span class="ot">=</span> xs <span class="op">++</span> <span class="fu">concat</span> xss</span></code></pre></div>
<h1 data-number="3" id="section-3"><span class="header-section-number">3</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>and :: [Bool] -&gt; Bool</code></p>
<p>and returns the conjunction of a Boolean list.</p>
<div class="sourceCode" id="cb2" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> []     <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">&amp;&amp;</span> <span class="fu">and</span> xs</span></code></pre></div>
<h1 data-number="4" id="section-4"><span class="header-section-number">4</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>or :: [Bool] -&gt; Bool</code></p>
<p>or returns the disjunction of a Boolean list.</p>
<h1 data-number="5" id="section-5"><span class="header-section-number">5</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>all</code></p>
<p>Applied to a predicate and a list, all determines if all elements of
the list satisfy the predicate. For example,</p>
<ul>
<li><code>all even [1..5] == False</code></li>
<li><code>all even [2,4,6] == True</code></li>
</ul>
<div class="sourceCode" id="cb3" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span> _ []     <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span> p (x<span class="op">:</span>xs) <span class="ot">=</span> p x <span class="op">&amp;&amp;</span> <span class="fu">all</span> p xs</span></code></pre></div>
<h1 data-number="6" id="section-6"><span class="header-section-number">6</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></p>
<div class="sourceCode" id="cb4" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ []     <span class="ot">=</span> []</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs</span></code></pre></div>
<h1 data-number="7" id="section-7"><span class="header-section-number">7</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>intersperse</code></p>
<p>The intersperse function takes an element and a list and
`intersperses’ that element between the elements of the list. For
example,</p>
<p><code>intersperse ',' "abcde" == "a,b,c,d,e"</code></p>
<h1 data-number="8" id="section-8"><span class="header-section-number">8</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>concatMap</code></p>
<p>Map a function over a list and concatenate the results.</p>
<h1 data-number="9" id="section-9"><span class="header-section-number">9</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>unlines :: [String] -&gt; String</code></p>
<p>unlines is an inverse operation to lines. It joins lines, after
appending a terminating newline to each.</p>
<h1 data-number="10" id="section-10"><span class="header-section-number">10</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
<p>filter, applied to a predicate and a list, returns the list of those
elements that satisfy the predicate; i.e.,</p>
<p><code>filter p xs = [ x | x &lt;- xs, p x]</code></p>
<h1 data-number="11" id="section-11"><span class="header-section-number">11</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>partition</code></p>
<p>The partition function takes a predicate a list and returns the pair
of lists of elements which do and do not satisfy the predicate,
respectively; i.e.,</p>
<p><code>partition p xs == (filter p xs, filter (not . p) xs)</code></p>
<div class="sourceCode" id="cb5" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>partition _ []                 <span class="ot">=</span> ([],[])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>partition p (x<span class="op">:</span>xs) <span class="op">|</span> p x       <span class="ot">=</span> <span class="kw">let</span> (ts,fs) <span class="ot">=</span> partition p xs <span class="kw">in</span> (x<span class="op">:</span>ts,  fs)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span> (ts,fs) <span class="ot">=</span> partition p xs <span class="kw">in</span> (  ts,x<span class="op">:</span>fs)</span></code></pre></div>
<h1 data-number="12" id="section-12"><span class="header-section-number">12</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>unzip :: [(a, b)] -&gt; ([a], [b])</code></p>
<p>unzip transforms a list of pairs into a list of first components and a
list of second components.</p>
<h1 data-number="13" id="section-13"><span class="header-section-number">13</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code></p>
<p>The insert function takes an element and a (sorted) list and inserts
the element into the list at the last position where it is still less
than or equal to the next element.</p>
<div class="sourceCode" id="cb6" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>insert q [] <span class="ot">=</span> [q]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>insert q (x<span class="op">:</span>xs) <span class="op">|</span> q <span class="op">&gt;</span> x     <span class="ot">=</span> x <span class="op">:</span> insert q xs</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> q <span class="op">:</span> x <span class="op">:</span> xs</span></code></pre></div>
<h1 data-number="14" id="section-14"><span class="header-section-number">14</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
<p>The sort function implements a sorting algorithm.</p>
<div class="sourceCode" id="cb7" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span> []     <span class="ot">=</span> []</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span> (x<span class="op">:</span>xs) <span class="ot">=</span> insert x (<span class="fu">sort</span> xs)</span></code></pre></div>
<h1 data-number="15" id="section-15"><span class="header-section-number">15</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>take</code></p>
<p>take i returns the first i elements from the input list. If the list
has fewer than i elements, the entire input list is returned.</p>
<div class="sourceCode" id="cb8" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot">          ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> <span class="dv">0</span> _      <span class="ot">=</span> []</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n []     <span class="ot">=</span> []</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> <span class="fu">take</span> (n<span class="op">-</span><span class="dv">1</span>) xs</span></code></pre></div>
<h1 data-number="16" id="section-16"><span class="header-section-number">16</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
<p>takeWhile, applied to a predicate p and a list xs, returns the longest
prefix (possibly empty) of xs of elements that satisfy p:</p>
<ul>
<li><code>takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]</code></li>
<li><code>takeWhile (&lt; 9) [1,2,3] == [1,2,3]</code></li>
<li><code>takeWhile (&lt; 0) [1,2,3] == []</code></li>
</ul>
<div class="sourceCode" id="cb9" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> _ []                 <span class="ot">=</span> []</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> p (x<span class="op">:</span>xs) <span class="op">|</span> p x       <span class="ot">=</span> x <span class="op">:</span> <span class="fu">takeWhile</span> p xs</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> []</span></code></pre></div>
<h1 data-number="17" id="section-17"><span class="header-section-number">17</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>group</code></p>
<p>The group function takes a list and returns a list of lists such that
the concatenation of the result is equal to the argument. Moreover,
each sublist in the result contains only equal elements. For example,</p>
<p><code>group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</code></p>
<div class="sourceCode" id="cb10" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">group</span> []     <span class="ot">=</span> []</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">group</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">case</span> <span class="fu">group</span> xs <span class="kw">of</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                 []                        <span class="ot">-&gt;</span> [[x]]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                 (ys<span class="op">@</span>(y<span class="op">:</span>_)<span class="op">:</span>rs) <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">-&gt;</span>      (x<span class="op">:</span>ys) <span class="op">:</span> rs</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                               <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> [x] <span class="op">:</span>    ys <span class="op">:</span> rs</span></code></pre></div>
<h1 data-number="18" id="section-18"><span class="header-section-number">18</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>remSuccessiveduplicates</code></p>
<p>The function remSuccessiveDuplicates removes succesive repeated
elements from a list. For example</p>
<p><code>remSuccessiveduplicates [1, 2, 2, 3, 2, 4] == [1, 2, 3, 2, 4]</code></p>
<div class="sourceCode" id="cb11" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>remSuccessiveduplicates []                   <span class="ot">=</span> []</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>remSuccessiveduplicates [x]                  <span class="ot">=</span> [x]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>remSuccessiveduplicates (x<span class="op">:</span>y<span class="op">:</span>xs) <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span> remsuccessiveduplicates (y<span class="op">:</span>xs)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> remsuccessiveduplicates (y<span class="op">:</span>xs)</span></code></pre></div>
<h1 data-number="19" id="section-19"><span class="header-section-number">19</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>nub</code></p>
<p>The nub function removes duplicate elements from a list. In
particular, it keeps only the first occurrence of each element. (The
name nub means `essence’.)</p>
<div class="sourceCode" id="cb12" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nub l                   <span class="ot">=</span> nub' l [] <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    nub' [] _           <span class="ot">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    nub' (x<span class="op">:</span>xs) seen</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> x <span class="ot">`elem`</span> seen   <span class="ot">=</span> nub' xs seen</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> x <span class="op">:</span> nub' xs (x<span class="op">:</span>seen)</span></code></pre></div>
<h1 data-number="20" id="section-20"><span class="header-section-number">20</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>union :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]</code></p>
<p>The union function returns the list union of the two lists. For example,</p>
<p><code>"dog" `union` "cow" == "dogcw"</code></p>
<p>Duplicates, and elements of the first list, are removed from the the
second list, but if the first list contains duplicates, so will the
result.</p>
<h1 data-number="21" id="section-21"><span class="header-section-number">21</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>intersect :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]</code></p>
<p>The intersect function takes the list intersection of two lists. For example,</p>
<p><code>[1,2,3,4] `intersect` [2,4,6,8] == [2,4]</code></p>
<p>If the first list contains duplicates, so will the result.</p>
<p><code>[1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]</code></p>
<h1 data-number="22" id="section-22"><span class="header-section-number">22</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>maybeLast :: [a] -&gt; Maybe a</code></p>
<p>Extract the last element of a list. Returns <code>Nothing</code> if the list is empty.</p>
<div class="sourceCode" id="cb13" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>maybeLast []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>maybeList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">case</span> maybeList xs <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                     jl      <span class="ot">-&gt;</span> jl</span></code></pre></div>
<h1 data-number="23" id="section-23"><span class="header-section-number">23</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>insertEverywhere</code></p>
<p>insertEverywhere x ys “inserts” x at every position in the list ys. I.e.:</p>
<p><code>insertEverywhere 10 [1..5] == [[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],[1,2,3,4,5,10]]</code></p>
<div class="sourceCode" id="cb14" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertEverywhere             ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>insertEverywhere x []        <span class="ot">=</span> [[x]]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>insertEverywhere x xs<span class="op">@</span>(y<span class="op">:</span>ys) <span class="ot">=</span> (x<span class="op">:</span>xs) <span class="op">:</span> <span class="fu">map</span> (y<span class="op">:</span>) (insertEverywhere x ys)</span></code></pre></div>
<h1 data-number="24" id="section-24"><span class="header-section-number">24</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>permutations :: [a] -&gt; [[a]]</code></p>
<p>The permutations function returns the list of all permutations of the
argument. E.g.:</p>
<p><code>permutations "abc" == ["abc","bac","bca","acb","cab","cba"]</code></p>
<p>Note that it is ok if your solution returns the permutations in any
order. E.g.</p>
<p><code>permutations "abc" == ["abc","bac","cba","bca","cab","acb"]</code></p>
<p>is also correct.</p>
<div class="sourceCode" id="cb15" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">permutations        ::</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>permutations []     <span class="ot">=</span> [[]]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>permutations (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">concatMap</span> (insertEverywhere x) <span class="op">$</span> permutations xs</span></code></pre></div>
<h1 data-number="25" id="section-25"><span class="header-section-number">25</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></p>
<p>The function foldr takes a function ‘f’ and an unit element ‘z’ and
“combines” all elements in the list using the function ‘f’, and
starting from value ‘z’.</p>
<p>Your implementation should satisfy:</p>
<ul>
<li><code>foldr (+) 0 xs == sum xs</code>, for any list of numbers xs, and</li>
<li><code>let f i s = chr i : s in foldr f "" [65..70] == "ABCDE"</code></li>
</ul>
<div class="sourceCode" id="cb16" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> _ z []     <span class="ot">=</span> z</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z (x<span class="op">:</span>xs) <span class="ot">=</span> f x (<span class="fu">foldr</span> f z xs)</span></code></pre></div>
<h1 data-number="26" id="section-26"><span class="header-section-number">26</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>scanr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</code></p>
<p>scanr is similar to foldr but returns a list of successive reduced
values from the right:</p>
<p><code>scanr f z [x_1, x_2, .., x_n] == [x_1 `f` .., .., x_(n-1) `f` z ,x_n `f` z,z]</code></p>
<p>That is, it also returns all intermediate answers of a foldr. Note in
particular that</p>
<p><code>head (scanr f z xs) == foldr f z xs</code>.</p>
<div class="sourceCode" id="cb17" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">scanr</span> _ z []     <span class="ot">=</span> [z]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">scanr</span> f z (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> rs<span class="op">@</span>(r<span class="op">:</span>_) <span class="ot">=</span> <span class="fu">scanr</span> f z xs</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> f x r <span class="op">:</span> rs</span></code></pre></div>
<h1 data-number="27" id="section-27"><span class="header-section-number">27</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>run length encoding: <code>encode</code></p>
<p>The function <code>encode</code> computes the run-length encoding of a list.
That is, the list is mapped to a list of pairs whose first element
says how many times the second component of the pair appears in
adjacent positions in the list. For example:</p>
<p><code>encode [1, 2, 2, 3, 2, 4]  == [(1, 1),(2, 2),(1, 3),(1, 2),(1, 4)]</code></p>
<div class="sourceCode" id="cb18" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">encode        ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>encode []     <span class="ot">=</span> []</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>encode (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">case</span> encode xs <span class="kw">of</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                  []                       <span class="ot">-&gt;</span> [(<span class="dv">1</span>,x)]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                  r<span class="op">@</span>((i,y)<span class="op">:</span>ys) <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">-&gt;</span> (i<span class="op">+</span><span class="dv">1</span>,x) <span class="op">:</span> ys</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                               <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> (<span class="dv">1</span>,x)   <span class="op">:</span> r</span></code></pre></div>
<h1 data-number="28" id="section-28"><span class="header-section-number">28</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>run length encoding: <code>decode</code></p>
<p>Given a run length encoded list, <code>decode</code> produces the original input
list, e.g. from the example above:</p>
<p><code>decode [(1, 1),(2, 2),(1, 3),(1, 2),(1, 4)] == [1, 2, 2, 3, 2, 4]</code></p>
<div class="sourceCode" id="cb19" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>decode <span class="ot">=</span> <span class="fu">concatMap</span> (\(i,x) <span class="ot">-&gt;</span> <span class="fu">replicate</span> i x)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">replicate</span> <span class="dv">0</span> _ <span class="ot">=</span> []</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">replicate</span> i x <span class="ot">=</span> x <span class="op">:</span> <span class="fu">replicate</span> (i<span class="op">-</span><span class="dv">1</span>) x</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- replicate is actually already defined in the Prelude.</span></span></code></pre></div>
<h1 data-number="29" id="section-29"><span class="header-section-number">29</span>  <span class="tag" data-tag-name="inClass"><span class="smallcaps">inClass</span></span></h1>
<p><code>splitAll :: Int -&gt; [a] -&gt; [[a]]</code></p>
<p>The splitAll function divides the given list in sublists, where the
sublists have the given length. Only the last list might be
shorter. For example,</p>
<p><code>splitAll 3 [1..11] == [[1,2,3],[4,5,6],[7,8,9],[10,11]]</code></p>
<p><strong>Hint</strong>: Try to think of a simpler problem first, and write a helper
function that solves this simpler problem.</p>
<div class="sourceCode" id="cb20" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | splitAt splits off the first i elements. Returns all elements in</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- the first list if there are fewer than i elements.</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span><span class="ot">          ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ([a],[a])</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> <span class="dv">0</span> xs     <span class="ot">=</span> ([],xs)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> i []     <span class="ot">=</span> ([],[])</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="fu">splitAt</span> i (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> (ys,rest) <span class="ot">=</span> <span class="fu">splitAt</span> (i<span class="op">-</span><span class="dv">1</span>) xs</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> (x<span class="op">:</span>ys,rest)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="ot">splitAll      ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>splitAll i xs <span class="ot">=</span> <span class="kw">case</span> <span class="fu">splitAt</span> i xs <span class="kw">of</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                  (ys,[])   <span class="ot">-&gt;</span> [ys]</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                  (ys,rest) <span class="ot">-&gt;</span> ys <span class="op">:</span> splitAll i rest</span></code></pre></div>
<h1 data-number="30" id="section-30"><span class="header-section-number">30</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p><code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>
<p>zipWith combines two lists into a single list, by pairwise applying
the given function. I.e. if <code>f</code> is the supplied function, and <code>x</code> and
<code>y</code> are the <span class="math inline">\(i^\mathrm{th}\)</span> elements in the first and second list,
respectively, the <span class="math inline">\(^i\mathrm{th}\)</span> element in the output list is <code>f x y</code>. If the lists have different length, the lengths are truncated to
the shortest list. For example:</p>
<ul>
<li><code>zipWith (,) [1,2,3,4] ["a","b","c","d","e"] == [(1,"a"),(2,"b"),(3,"c"),(4,"d")]</code></li>
<li><code>zipWith (+) [1,2,3] [100,200,300,400] == [1001,2002,3003]</code></li>
</ul>
<div class="sourceCode" id="cb21" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> f (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> (f x y) <span class="op">:</span> <span class="fu">zipWith</span> f xs ys</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> _ _      _      <span class="ot">=</span> []</span></code></pre></div>
<h1 data-number="31" id="section-31"><span class="header-section-number">31</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p><code>transpose :: [[a]] -&gt; [[a]]</code></p>
<p>Transposes a matrix (represented by a list of equally long
lists). That is, the function <code>transpose :: [[a]] -&gt; [[a]]</code> which maps
the <span class="math inline">\(i^\mathrm{th}\)</span> element of the <span class="math inline">\(j^\mathrm{th}\)</span> list to the
<span class="math inline">\(j^\mathrm{th}\)</span> element of the <span class="math inline">\(i^\mathrm{th}\)</span> list.</p>
<p><strong>Hint:</strong> make use of the function <code>zipWith</code>.</p>
<div class="sourceCode" id="cb22" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- The main work is done here; we consider the first row separately,</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- transpose the rest of the matrix (without its first row), and then</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- cons the elements from the first row onto the result.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- If there are no rows left we generate sufficiently many (infinitely</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- many) empty rows that this consing/combining described above is</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- successful. The zipWith function will just truncate the empty</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- leftover rows generated.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>transpose' (xs<span class="op">:</span>xss) <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">:</span>) xs (transpose' xss)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>transpose' []       <span class="ot">=</span> <span class="fu">repeat</span> []</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- The above function transpose' transposes non-empty matrices. But</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- when the matrix empty at the very start we get this infinite list</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- of empty lists instead. We should fix that:</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>transpose [] <span class="ot">=</span> []</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>transpose xs <span class="ot">=</span> transpose' xs</span></code></pre></div>
<h1 data-number="32" id="maximum-segment-sum"><span class="header-section-number">32</span> Maximum Segment Sum <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span> <span class="tag" data-tag-name="challenging"><span class="smallcaps">challenging</span></span></h1>
<p>Given a list of numbers, we define a <em>segment</em> as a contiguous
sublist. For example <code>[2,3,4]</code> is a segment of <code>l=[1,2,3,4,5,6]</code> but
<code>[2,4,6]</code> is not a segment of <code>l</code>. The sum of a segment is the value
we obtain by summing all values in a segment, and the <em>maximum segment
sum</em> of <code>l</code> is the maximum sum over all possible segments of <code>l</code>.</p>
<ol type="1">
<li><p>Write the function <code>segments</code> that computes all segments of a list
by combine existing functions from Data.List (which you have
re-implemented in the exercises above)</p>
<div class="sourceCode" id="cb23" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">segments ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>segments <span class="ot">=</span> ([] <span class="op">:</span>) <span class="op">.</span> <span class="fu">concatMap</span> (<span class="fu">tail</span> <span class="op">.</span> List.inits) <span class="op">.</span> List.tails</span></code></pre></div></li>
<li><p>implement <code>maximumSegmentSum</code> using a combination of existing List functions.</p>
<div class="sourceCode" id="cb24" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>maxSegSumSpec <span class="ot">=</span> <span class="fu">maximum</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">sum</span> <span class="op">.</span> segments</span></code></pre></div></li>
<li><p>The above implementation is simple, but actually very slow
(<span class="math inline">\(O(n^3)\)</span> time). With a bit of work we can derive a linear time
implementation instead!</p>
<p>Write, using direct recursion, a function <code>maxPrefixSum</code> that
computes the maximum among all prefixes of a list.</p>
<div class="sourceCode" id="cb25" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxPrefixSum        ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>maxPrefixSum []     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>maxPrefixSum (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">0</span> <span class="ot">`max`</span> (x <span class="op">+</span> maxPrefixSum xs)</span></code></pre></div></li>
<li><p>Implement a function <code>maximumSegSum</code> with direct recursion.</p>
<div class="sourceCode" id="cb26" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>maxSegSum []     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>maxSegSum (x<span class="op">:</span>xs) <span class="ot">=</span> maxSegSum xs <span class="ot">`max`</span> (x <span class="op">+</span> maxPrefixSum xs)</span></code></pre></div></li>
<li><p>Hopefully you can notice some commonality in the implementation of
<code>maxPrefixSum</code> and <code>maxSegSum</code>. Exploit that to obtain a linear
time implementation <code>maxSegSum</code> for the maximum segment sum.</p>
<p>Hint: Write a function <code>maxPrefixAndSegSum : [Int] -&gt; (Int,Int)</code> that
<em>simultaneously</em> computes the maximum prefix sum and the maximum
segment sum. I.e. Your function should satisfy the specification:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>maxPrefixAndSegSum xs <span class="ot">=</span> (maxPrefixSum xs, maxSegSum xs)</span></code></pre></div>
<div class="sourceCode" id="cb28" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxPrefixAndSegSum        ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>,<span class="dt">Int</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>maxPrefixAndSegSum []     <span class="ot">=</span> (<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>maxPrefixAndSegSum (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> (maxPrefix,maxSeg) <span class="ot">=</span> maxPrefixAndSegSum xs</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                                candidatePrefix    <span class="ot">=</span> x <span class="op">+</span> maxPrefix</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> (<span class="dv">0</span>       <span class="ot">`max`</span> candidatePrefix</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                               , maxSeg <span class="ot">`max`</span> candidatePrefix</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                               )</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="ot">maxSegSum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>maxSegSum <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> maxPrefixAndSegSum</span></code></pre></div></li>
</ol>
<h1 data-number="33" id="section-32"><span class="header-section-number">33</span>  <span class="tag" data-tag-name="atHome"><span class="smallcaps">atHome</span></span></h1>
<p>Let <code>countTrues :: [Bool] -&gt; [int]</code> be a function such that <code>countTrues bs</code> computes, for
each prefix of the list <code>bs</code>, the number of <code>True</code> s in the list.</p>
<ol type="1">
<li><p>Write <code>countTrues</code> using direct recursion.</p>
<p>Hint: Take another look at your implementation of <code>inits</code> first.</p>
<div class="sourceCode" id="cb29" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrues            ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>countTrues []         <span class="ot">=</span> [<span class="dv">0</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>countTrues (<span class="dt">True</span><span class="op">:</span>bs)  <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) (countTrues bs)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>countTrues (<span class="dt">False</span><span class="op">:</span>bs) <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> countTrues bs</span></code></pre></div></li>
<li><p>Write <code>countTrues</code> using a combination of existing functions.</p>
<div class="sourceCode" id="cb30" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrues    ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>countTrues bs <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span> <span class="dt">True</span>)) <span class="op">.</span> inits <span class="op">$</span> bs</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- note that we can eta-reduce to</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrues ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>countTrues <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span> <span class="dt">True</span>)) <span class="op">.</span> inits</span></code></pre></div></li>
<li><p>Write <code>countTrues</code> using an accumulator so that your
implementation runs in linear time.</p>
<div class="sourceCode" id="cb31" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrues ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>countTrues <span class="ot">=</span> count [<span class="dv">0</span>]</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- invariant: count acc xs == (reverse acc) ++ countTrues xs</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    count acc          []        <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    count acc<span class="op">@</span>(cur<span class="op">:</span>_) (<span class="dt">True</span><span class="op">:</span>bs)  <span class="ot">=</span> count (cur<span class="op">+</span><span class="dv">1</span> <span class="op">:</span> acc) bs</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    count acc<span class="op">@</span>(cur<span class="op">:</span>_) (<span class="dt">False</span><span class="op">:</span>bs) <span class="ot">=</span> count (cur   <span class="op">:</span> acc) bs</span></code></pre></div></li>
<li><p>Write an alternative implementation of <code>countTrues</code> (not using an
accumulator) that also runs in linear time.</p>
<div class="sourceCode" id="cb32" data-solution="yes"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countTrues ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>countTrues <span class="ot">=</span> <span class="fu">reverse</span> <span class="op">.</span> count <span class="op">.</span> <span class="fu">reverse</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    count []         <span class="ot">=</span> [<span class="dv">0</span>]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    count (<span class="dt">True</span> <span class="op">:</span>bs) <span class="ot">=</span> <span class="kw">let</span> res<span class="op">@</span>(cur<span class="op">:</span>_) <span class="ot">=</span> count bs <span class="kw">in</span> cur <span class="op">+</span> <span class="dv">1</span> <span class="op">:</span> res</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    count (<span class="dt">False</span><span class="op">:</span>bs) <span class="ot">=</span> <span class="kw">let</span> res<span class="op">@</span>(cur<span class="op">:</span>_) <span class="ot">=</span> count bs <span class="kw">in</span> cur     <span class="op">:</span> res</span></code></pre></div></li>
</ol>
    </div>
  </body>
</html>
