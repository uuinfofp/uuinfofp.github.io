<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Functional Programming - Solutions to selected exercises</title>
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    <link rel="stylesheet" href="./css/syntax.css">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="./js/bootstrap.min.js"></script>
    <script src="./js/bootstrapify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
  </head>
  <body>
    <!-- Static navbar -->
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./index.html">Functional Programming</a> <!--  -->
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <!-- <li><a href="/description.html">Description</a></li> -->
            <li><a href="./lectures.html">Lectures</a></li>
            <li><a href="./labs.html">Practicals</a></li>
            <li><a href="./exercises.html">Exercises</a></li>
            <li><a href="./optional.html">Optional Assignment</a></li>
            <li><a href="./exams.html">Old Exams</a></li>
            <!-- <li><a href="projects.html">Projects</a></li> -->
            <li><a target="_blank" href="https://cursusplanner.uu.nl/course/INFOFP/2025/1">Education page</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container" id="main">
      <h2>Solutions to selected exercises</h2>

      <h3 id="lectures-1-and-2---functions-and-types">Lectures 1 and 2 - Functions and types</h3>
<h4 id="exercise-1">Exercise 1</h4>
<p>The number of solutions is given by the result of the discriminant, <code>bÂ² - 4ac</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>noOfSol a b c <span class="op">|</span> discr <span class="op">&gt;</span>  <span class="dv">0</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> discr <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> discr <span class="ot">=</span> b <span class="op">*</span> b <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> a <span class="op">*</span> c</span></code></pre></div>
<h4 id="exercises-2-and-3">Exercises 2 and 3</h4>
<p>Remember that you can use <code>ghci</code> to ask for the type of an expression or its value:</p>
<pre><code>&gt; :t (++) [True, False]
append [True, False] :: [Bool] -&gt; [Bool]
&gt; [1,2] ++ [3,4]
[1,2,3,4]</code></pre>
<h4 id="type-inference">Type inference</h4>
<p>The types of <code>map . foldr</code> and <code>map (map map)</code> have been discussed in the Q&amp;A session before the mid-term exam.</p>
<h3 id="lecture-3---lists-and-recursion">Lecture 3 - Lists and recursion</h3>
<h4 id="exercise-1-1">Exercise 1</h4>
<p>The evaluation of <code>factorial n</code> for any negative number loops indefinitely. The reason is that there is no base case to stop the recursion.</p>
<h4 id="exercise-2">Exercise 2</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">^</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">^</span> n <span class="op">|</span> n <span class="ot">`rem`</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> y <span class="op">*</span> y</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> x <span class="op">*</span> y <span class="op">*</span> y</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> y <span class="ot">=</span> x <span class="op">^</span> (n <span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
<h4 id="exercise-3">Exercise 3</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> []     <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;empty list&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> [x]    <span class="ot">=</span> x</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="fu">last</span> (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">last</span> xs</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Another version which does not raise errors</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">last' ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>last' []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>last' [x]    <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>last' (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">last</span> xs</span></code></pre></div>
<h4 id="exercise-5">Exercise 5</h4>
<p>In this solution I assume that the indices start at 0. E.g., <code>[1,2] !! 0 = 1</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>_      <span class="op">!!</span> n</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;negative index&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>[]     <span class="op">!!</span> _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;not enough elements&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>_)  <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> x</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>xs) <span class="op">!!</span> n <span class="ot">=</span> xs <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h4 id="exercise-6">Exercise 6</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isPalindrome ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>isPalindrome xs <span class="ot">=</span> xs <span class="op">==</span> <span class="fu">reverse</span> xs</span></code></pre></div>
<h4 id="exercises-8-9-and-10">Exercises 8, 9 and 10</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">remSuccessiveDuplicates ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>remSuccessiveDuplicates []     <span class="ot">=</span> []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>remSuccessiveDuplicates (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> remSuccessiveDuplicates' x xs</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span><span class="ot"> remSuccessiveDuplicates' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        remSuccessiveDuplicates' x [] <span class="ot">=</span> []</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        remSuccessiveDuplicates' x (y<span class="op">:</span>ys)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span>     remSuccessiveDuplicates' x ys  <span class="co">-- We found the same element</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> remSuccessiveDuplicates' y ys  <span class="co">-- Start with a new value                                      </span></span></code></pre></div>
<p>Exercies 9 and 10 are a variation of exercise 8, in which you need to keep extra information. Note also that:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>runLengthEncoding <span class="ot">=</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> (<span class="fu">length</span> x, <span class="fu">head</span> x)) <span class="op">.</span> <span class="fu">group</span></span></code></pre></div>
<h4 id="exercise-15">Exercise 15</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">split ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>split n xs <span class="ot">=</span> split' n xs</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span><span class="ot"> split' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        split' _ []     <span class="ot">=</span> []</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        split' <span class="dv">0</span> xs     <span class="ot">=</span> split' n xs  <span class="co">-- Start again</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        split' n (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> (t<span class="op">:</span>ts) <span class="ot">=</span> split' (n<span class="op">-</span><span class="dv">1</span>) xs <span class="kw">in</span> ((x<span class="op">:</span>t)<span class="op">:</span>ts)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">-- Add one to the first list</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using built-in functions</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>split _ [] <span class="ot">=</span> []</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>split n xs <span class="ot">=</span> <span class="fu">take</span> n xs <span class="op">:</span> split n (<span class="fu">drop</span> n xs)</span></code></pre></div>
<h3 id="lecture-4---higher-order-functions">Lecture 4 - Higher-order functions</h3>
<h4 id="exercise-1-2">Exercise 1</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyToZero ::</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>) <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>applyToZero f <span class="ot">=</span> f <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>add x <span class="ot">=</span> \y <span class="ot">-&gt;</span> x <span class="op">+</span> y</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- or taking currying into account</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- or even reducing the arguments</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>add <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>) <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> f <span class="ot">=</span> f  <span class="co">-- identity works here</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>) <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>apply f n <span class="ot">=</span> f n  <span class="co">-- apply 'f' to 'n'</span></span></code></pre></div>
<h4 id="exercise-2-1">Exercise 2</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">++</span>) []</span></code></pre></div>
<h4 id="exercise-4">Exercise 4</h4>
<p>The idea here is that we will turn a list into a lists of lists. Each of these inner lists will be either empty, if we want to remove the item, or just hold a single value if we want to preserve it. If we then flatten those inner lists with <code>concat</code>, we are done.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> <span class="fu">map</span> box</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> box x <span class="op">|</span> p x       <span class="ot">=</span> [x]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> []</span></code></pre></div>
<h4 id="exercise-5-1">Exercise 5</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">before ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>before f g <span class="ot">=</span> \x <span class="ot">-&gt;</span> g (f x)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Also, before is usual composition with its arguments flipped</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">before ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>before <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<h4 id="exercise-6-1">Exercise 6</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- The type of map for lists</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- We could also write it by putting [] in front</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [] a <span class="ot">-&gt;</span> [] b</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Now we substitute [] for (c -&gt;)</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ot">mapFn ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is just function composition! ;)</span></span></code></pre></div>
<h3 id="lecture-5---data-types-and-type-classes">Lecture 5 - Data types and type classes</h3>
<h4 id="exercise-1-3">Exercise 1</h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Complex</span> <span class="ot">=</span> <span class="dt">C</span> <span class="dt">Float</span> <span class="dt">Float</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Complex</span> <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> a b) <span class="op">+</span> (<span class="dt">C</span> x y) <span class="ot">=</span> <span class="dt">C</span> (a <span class="op">+</span> x)    (b <span class="op">+</span> y)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> a b) <span class="op">-</span> (<span class="dt">C</span> x y) <span class="ot">=</span> <span class="dt">C</span> (a <span class="op">-</span> x)    (b <span class="op">-</span> y)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> a b) <span class="op">*</span> (<span class="dt">C</span> x y) <span class="ot">=</span> <span class="dt">C</span> (a<span class="op">*</span>x<span class="op">-</span>b<span class="op">*</span>y)  (a<span class="op">*</span>y<span class="op">+</span>b<span class="op">*</span>x)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">negate</span> (<span class="dt">C</span> a b)    <span class="ot">=</span> <span class="dt">C</span> (<span class="fu">negate</span> a) (<span class="fu">negate</span> b)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span>    (<span class="dt">C</span> a b)    <span class="ot">=</span> <span class="dt">C</span> (a<span class="op">*</span>a<span class="op">+</span>b<span class="op">*</span>b)  <span class="dv">0</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> i     <span class="ot">=</span> <span class="dt">C</span> (<span class="fu">fromInteger</span> i) <span class="dv">0</span></span></code></pre></div>
<h4 id="exercise-3-1">Exercise 3</h4>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Set</span> a <span class="ot">=</span> <span class="dt">Set</span> [a]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 'xs' is a subset of 'ys' if every element</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- of 'xs' is an element of 'ys'</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">subset ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>subset (<span class="dt">Set</span> xs) (<span class="dt">Set</span> ys) <span class="ot">=</span> <span class="fu">all</span> (\x <span class="ot">-&gt;</span> <span class="fu">elem</span> x ys) xs</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Set</span> a) <span class="kw">where</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  (<span class="op">==</span>) <span class="ot">=</span> subset</span></code></pre></div>
<p>We need to make <code>Set a</code> its own data type because otherwise we would get two conflicting instances for <code>[a]</code>.</p>
<h4 id="exercise-4-1">Exercise 4</h4>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Finite</span> a <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  elements ::</span> [a]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  elements <span class="ot">=</span> [<span class="dt">False</span>, <span class="dt">True</span>]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Finite</span> a, <span class="dt">Finite</span> b) <span class="ot">=&gt;</span> <span class="dt">Finite</span> (a, b) <span class="kw">where</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  elements <span class="ot">=</span> [(x, y) <span class="op">|</span> x <span class="ot">&lt;-</span> elements, y <span class="ot">&lt;-</span> elements]</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Auxiliary definition for Finite (Set a)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Computes all subsets for the given elements,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- that is, all combinations where each element</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- in the list may or may not appear</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="ot">allSubsets ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Set</span> a]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>allSubsets []     <span class="ot">=</span> [[]]</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>allSubsets (v<span class="op">:</span>vs) <span class="ot">=</span> <span class="kw">let</span> ss <span class="ot">=</span> allSubsets vs</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> ss <span class="op">++</span> [v<span class="op">:</span>s <span class="op">|</span> s <span class="ot">&lt;-</span> ss]</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Finite</span> a <span class="ot">=&gt;</span> <span class="dt">Finite</span> (<span class="dt">Set</span> a) <span class="kw">where</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  elements <span class="ot">=</span> allSubsets elements</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Auxiliary definition for Finite (a -&gt; b)</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Computes all key-value pairs from two lists,</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- the first one gives the keys and the second</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- one gives the possible values</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="ot">allKVPairs ::</span> [k] <span class="ot">-&gt;</span> [v] <span class="ot">-&gt;</span> [[(k, v)]]</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>allKVPairs []     _  <span class="ot">=</span> [[]]</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>allKVPairs (k<span class="op">:</span>ks) vs <span class="ot">=</span> [(k,v)<span class="op">:</span>kvs</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>                         <span class="op">|</span> kvs <span class="ot">&lt;-</span> allKVPairs ks vs</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>                         , v   <span class="ot">&lt;-</span> vs]</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Finite</span> a, <span class="dt">Finite</span> b, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Finite</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>  elements <span class="ot">=</span> [\k <span class="ot">-&gt;</span> fromJust (<span class="fu">lookup</span> k kv)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> kv <span class="ot">&lt;-</span> allKVPairs elements elements]</span></code></pre></div>
<h3 id="lecture-6---data-structures">Lecture 6 - Data structures</h3>
<h4 id="exercise-1-4">Exercise 1</h4>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elemTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>elemTree q t <span class="ot">=</span> succOf q t <span class="op">==</span> q</span></code></pre></div>
<p>or directly:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elemTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>elemTree _ <span class="dt">Leaf</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>elemTree q (<span class="dt">Node</span> l x r) <span class="op">|</span> q <span class="op">&lt;</span> x     <span class="ot">=</span> elemTree q l</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> q <span class="op">==</span> x    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> elemTree q r</span></code></pre></div>
<h4 id="exercise-2-2">Exercise 2</h4>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseTree ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>traverseTree _       <span class="dt">Leaf</span>         <span class="ot">=</span> []</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>traverseTree combine (<span class="dt">Node</span> l x r) <span class="ot">=</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  combine x (traverseTree l) (traverseTree r)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ot">preOrderTraversal ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>preOrderTraversal <span class="ot">=</span> traverseTree (\l x r <span class="ot">-&gt;</span> x <span class="op">:</span> (l <span class="op">++</span> r))</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="ot">inOrderTraversal ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>inOrderTraversal <span class="ot">=</span> traverseTree (\l x r <span class="ot">-&gt;</span> l <span class="op">++</span> (x <span class="op">:</span> r))</span></code></pre></div>
<h4 id="exercise-7">Exercise 7</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">paths ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>paths <span class="dt">Leaf</span>         <span class="ot">=</span> [[]]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>paths (<span class="dt">Node</span> l x r) <span class="ot">=</span> <span class="fu">map</span> (x<span class="op">:</span>) (paths l) <span class="op">++</span> <span class="fu">map</span> (x<span class="op">:</span>) (paths r)</span></code></pre></div>
<h3 id="lecture-7---case-studies">Lecture 7 - Case studies</h3>
<p>Here is the definition of <code>Prop</code> we use in the slides:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Prop</span> <span class="ot">=</span> <span class="dt">Basic</span> <span class="dt">Bool</span> <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Char</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Not</span> <span class="dt">Prop</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Prop</span> <span class="op">:/</span>\<span class="op">:</span> <span class="dt">Prop</span> <span class="op">|</span> <span class="dt">Prop</span> <span class="op">:</span>\<span class="op">/:</span> <span class="dt">Prop</span> <span class="op">|</span> <span class="dt">Prop</span> <span class="op">:=&gt;:</span> <span class="dt">Prop</span></span></code></pre></div>
<h4 id="exercise-1-5">Exercise 1</h4>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">printProp ::</span> <span class="dt">Prop</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>printProp (<span class="dt">Basic</span> b) <span class="ot">=</span> <span class="fu">show</span> b</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>printProp (<span class="dt">Var</span> v) <span class="ot">=</span> [v]</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>printProp (<span class="dt">Not</span> p)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="st">&quot;not &quot;</span> <span class="op">++</span> parensPrintProp p</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>printProp (p1 <span class="op">:/</span>\<span class="op">:</span> p2) <span class="ot">=</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parensPrintProp p1 <span class="op">++</span> <span class="st">&quot; /\ &quot;</span> <span class="op">++</span> parensPrintProp p2</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>printProp (p1 <span class="op">:</span>\<span class="op">/:</span> p2) <span class="ot">=</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parensPrintProp p1 <span class="op">++</span> <span class="st">&quot; \/ &quot;</span> <span class="op">++</span> parensPrintProp p2</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>printProp (p1 <span class="op">:=&gt;:</span> p2) <span class="ot">=</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> parensPrintProp p1 <span class="op">++</span> <span class="st">&quot; =&gt; &quot;</span> <span class="op">++</span> parensPrintProp p2</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> parens s <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> s <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        parensPrintProp p <span class="ot">=</span> parens (printProp p)</span></code></pre></div>
<h4 id="exercise-2-3">Exercise 2</h4>
<p>Using the definitions in the slides, we can write it quite concisely. The only thing to change is the check <em>for every</em> assignment into a check for <em>at least one</em> assignment.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using or :: [Bool] -&gt; Bool</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>satisfiable p <span class="ot">=</span> <span class="fu">or</span> [tv as p <span class="op">|</span> as <span class="ot">&lt;-</span> assigns (vars p)]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using any :: (a -&gt; Bool) -&gt; [a] -&gt; Bool</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>satisfiable p <span class="ot">=</span> <span class="fu">any</span> (\as <span class="ot">-&gt;</span> tv as p) (assigns (vars p))</span></code></pre></div>
<p>If we want to refine it, we can use the function <code>find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a</code> to return the assignment which makes the proposition true.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">satisfiable ::</span> <span class="dt">Prop</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Bool</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>satisfiable <span class="ot">=</span> find (\as <span class="ot">-&gt;</span> tv as p) (assigns (vars p))</span></code></pre></div>
<h4 id="exercise-3-2">Exercise 3</h4>
<p>Our original definition of <code>ArithExpr</code> only accounted for binary operations. But factorial is unary, so we need to expand the data type on that respect. Exponentiation is just a new binary operation, which we can put together with <code>Plus</code>, <code>Minus</code> and so on.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UnArithOp</span>  <span class="ot">=</span> <span class="dt">Factorial</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BinArithOp</span> <span class="ot">=</span> <span class="dt">Plus</span> <span class="op">|</span> <span class="dt">Minus</span> <span class="op">|</span> <span class="dt">Times</span> <span class="op">|</span> <span class="dt">Div</span> <span class="op">|</span> <span class="dt">Exp</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ArithExpr</span> <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Integer</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Variable</span> <span class="dt">Char</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">UnOp</span>  <span class="dt">UnArithOp</span>  <span class="dt">ArithExpr</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">BinOp</span> <span class="dt">BinArithOp</span> <span class="dt">ArithExpr</span> <span class="dt">ArithExpr</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">ArithExpr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>eval _ (<span class="dt">Constant</span> c)  <span class="ot">=</span> c</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>eval m (<span class="dt">Variable</span> v)  <span class="ot">=</span> fromJust (<span class="fu">lookup</span> v m)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>eval m (<span class="dt">UnOp</span>  o x)   <span class="ot">=</span> evalUnOp  o (eval m x)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> evalUnOp <span class="dt">Factorial</span> <span class="ot">=</span> \x <span class="ot">-&gt;</span> <span class="fu">product</span> [<span class="dv">1</span> <span class="op">..</span> x]</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>eval m (<span class="dt">BinOp</span> o x y) <span class="ot">=</span> evalBinOp o (eval m x) (eval m y)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> evalBinOp <span class="dt">Plus</span>  <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        evalBinOp <span class="dt">Minus</span> <span class="ot">=</span> (<span class="op">-</span>)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>        evalBinOp <span class="dt">Times</span> <span class="ot">=</span> (<span class="op">*</span>)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        evalBinOp <span class="dt">Div</span>   <span class="ot">=</span> <span class="fu">div</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        evalBinOp <span class="dt">Exp</span>   <span class="ot">=</span> (<span class="op">^^</span>)</span></code></pre></div>
<h3 id="lecture-13---project-management-testing-with-quickcheck">Lecture 13 - Project management: testing with QuickCheck</h3>
<h4 id="exercise-1-6">Exercise 1</h4>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">propFilterNoLonger ::</span> (a â<span class="op">&gt;</span> a) â<span class="op">&gt;</span> [a] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>propFilterNoLonger p xs <span class="ot">=</span> <span class="fu">length</span> (<span class="fu">filter</span> p xs) <span class="op">&lt;=</span> <span class="fu">length</span> xs</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">propFilterAllSatisfy ::</span> (a â<span class="op">&gt;</span> a) â<span class="op">&gt;</span> [a] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>propFilterAllSatisfy p xs <span class="ot">=</span> <span class="fu">all</span> p (<span class="fu">filter</span> p xs)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="ot">propFilterAllElements ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a â<span class="op">&gt;</span> a) â<span class="op">&gt;</span> [a] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>propFilterAllElements p xs <span class="ot">=</span> <span class="fu">all</span> (<span class="ot">`elem`</span> xs) (<span class="fu">filter</span> p xs)</span></code></pre></div>
<p>In order to completely characterize the <code>filter</code> function you should add two properties:</p>
<ul>
<li>That the elements which are left out do not satisfy the property.</li>
<li>That the result of <code>filter p xs</code> is a sublist of <code>xs</code>, that is, a copy of <code>xs</code> where some elements are removed but the order of the elements is respected.</li>
</ul>
<h4 id="exercise-2-4">Exercise 2</h4>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">propMapLength ::</span> (a â<span class="op">&gt;</span> b) â<span class="op">&gt;</span> [a] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>propMapLength f xs <span class="ot">=</span> <span class="fu">length</span> xs <span class="op">==</span> <span class="fu">length</span> (<span class="fu">map</span> f xs)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">propMapId ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>propMapId xs <span class="ot">=</span> <span class="fu">map</span> <span class="fu">id</span> xs <span class="op">==</span> xs</span></code></pre></div>
<p>One property which is difficult to verify is the distributivity over composition, that is, that <code>map (f . g) = map f . map g</code>. This is because generating arbitrary functions is a complicated task.</p>
<h4 id="exercise-3-3">Exercise 3</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">propPermsLength ::</span> [<span class="dt">Int</span>] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>propPermsLength xs <span class="ot">=</span> <span class="fu">length</span> (permutations xs) <span class="op">==</span> factorial (<span class="fu">length</span> xs)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">isPerm ::</span> [a] â<span class="op">&gt;</span> [a] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>isPerm xs ys <span class="ot">=</span> <span class="fu">length</span> xs <span class="op">==</span> <span class="fu">length</span> ys <span class="op">&amp;&amp;</span> <span class="fu">all</span> (<span class="ot">`elem`</span> ys) xs</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="ot">propPermsArePerms ::</span> [<span class="dt">Int</span>] â<span class="op">&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>propPermsArePerms xs <span class="ot">=</span> <span class="fu">all</span> (isPerm xs) (permutations xs)</span></code></pre></div>
<p>An additional property which characterized <code>permutations</code> is that given a list without duplicates, the set of permutations does not contain duplicate elements either.</p>
<h3 id="lecture-9---input-and-output">Lecture 9 - Input and output</h3>
<h4 id="exercise-1-7">Exercise 1</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> l <span class="ot">&lt;-</span> randomRIO (<span class="dv">1</span>,  <span class="dv">50</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>          u <span class="ot">&lt;-</span> randomRIO (<span class="dv">51</span>, <span class="dv">100</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>          guess l u</span></code></pre></div>
<h4 id="exercise-2-5">Exercise 2</h4>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> []     <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> (r<span class="op">:</span>rs) <span class="ot">=</span> r <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">sequence</span> rs <span class="op">&gt;&gt;=</span> \xs <span class="ot">-&gt;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> (x<span class="op">:</span>xs)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence_</span> []     <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence_</span> (r<span class="op">:</span>rs) <span class="ot">=</span> r <span class="op">&gt;&gt;</span> <span class="fu">sequence_</span> rs</span></code></pre></div>
<h4 id="exercise-4-2">Exercise 4</h4>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> <span class="fu">putStr</span> <span class="st">&quot;Give a number:&quot;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>   n <span class="ot">&lt;-</span> getInt</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>   forM_ [<span class="dv">1</span> <span class="op">..</span> <span class="dv">10</span>] <span class="op">$</span> \m <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>     <span class="fu">putStr</span> (<span class="fu">show</span> m)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>     <span class="fu">putStr</span> <span class="st">&quot; * &quot;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>     <span class="fu">putStr</span> (<span class="fu">show</span> n)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>     <span class="fu">putStr</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>     <span class="fu">putStrLn</span> (<span class="fu">show</span> (m <span class="op">*</span> n))</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>   <span class="fu">putStrLn</span> <span class="st">&quot;Goodbye&quot;</span></span></code></pre></div>
<h4 id="exercise-5-2">Exercise 5</h4>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">appendAll ::</span> [<span class="dt">FilePath</span>] â<span class="op">&gt;</span> <span class="dt">FilePath</span> â<span class="op">&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>appendAll inputs output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> <span class="fu">mapM</span> <span class="fu">readFile</span> inputs</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">writeFile</span> output (<span class="fu">concat</span> contents)</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> out <span class="ot">&lt;-</span> askOutputPath</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>          ins <span class="ot">&lt;-</span> askInputPaths</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>          appendAll ins out</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ot">askOutputPath ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>askOutputPath <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStr</span> <span class="st">&quot;Output path: &quot;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>                   line <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">case</span> line <span class="kw">of</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>                     <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Invalid path&quot;</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>                              askOutputPath</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>                     _  <span class="ot">-&gt;</span> <span class="fu">return</span> line</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="ot">askInputPaths ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>askInputPaths <span class="ot">=</span> <span class="fu">reverse</span> (askInputPaths' [])</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> askInputPaths' acc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStr</span> <span class="st">&quot;Input path: &quot;</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>          line <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> line <span class="kw">of</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> <span class="fu">return</span> acc</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>            x  <span class="ot">-&gt;</span> askInputPaths' (x<span class="op">:</span>acc)</span></code></pre></div>
<h3 id="lecture-10---laws-and-induction">Lecture 10 - Laws and induction</h3>
<p>Solutions to several of the exercises can be found in Chapter 16 of the <a href="http://www.staff.science.uu.nl/~hage0101/FP-elec.pdf">Lecture Notes</a>.</p>
<h3 id="lecture-11---lazy-evaluation">Lecture 11 - Lazy evaluation</h3>
<h4 id="exercise-1-8">Exercise 1</h4>
<p>Given that definition, when the machine computes the result of <code>intersperse 'a' ('b' : undefined)</code>, it first checks whether the constructor for the second argument is <code>[]</code> or <code>(:)</code>. We know that from the code, so nothing additional needs to be forced. However, to decide between the second and third branches it needs to know the next constructor, since it needs to distinguish <code>x : []</code> from <code>x : (y : zs)</code>. Because at that point the expression is undefined, the result of <code>intersperse 'a' ('b' : undefined)</code> is also undefined.</p>
<p>In order to make the definition less strict, we need to pattern match as little as possible. One way to do this is taking the first element as is, and then prepending the separator to the rest:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>intersperse _ []     <span class="ot">=</span> []</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>intersperse s (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> intersperse' xs</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> intersperse' []     <span class="ot">=</span> []</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        intersperse' (y<span class="op">:</span>ys) <span class="ot">=</span> s <span class="op">:</span> y <span class="op">:</span> intersperse' ys</span></code></pre></div>
<p>Using this definition, the result of <code>intersperse</code> produces two elements before it gets to the undefined part of the list. In other words, the result of the execution is <code>'b' : 'a' : undefined</code>.</p>
<h3 id="lectures-12-and-13---functors-monads-applicatives-and-traversables">Lectures 12 and 13 - Functors, monads, applicatives and traversables</h3>
<h4 id="exercise-2-6">Exercise 2</h4>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m (a, b)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using do notation</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>tuple x y <span class="ot">=</span> <span class="kw">do</span> x' <span class="ot">&lt;-</span> x</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>               y' <span class="ot">&lt;-</span> y</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>               <span class="fu">return</span> (x', y')</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using explicit binds</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>tuple x y <span class="ot">=</span> x <span class="op">&gt;&gt;=</span> \x' <span class="ot">-&gt;</span> x <span class="op">&gt;&gt;=</span> \y' <span class="ot">-&gt;</span> <span class="fu">return</span> (x', y')</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Use applicative operators</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>tuple x y <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> x <span class="op">&lt;*&gt;</span> y</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Even shorter</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>tuple <span class="ot">=</span> liftM2 (,)</span></code></pre></div>
<p>In the <code>Maybe</code> case this function returns a tuple in a <code>Just</code> only if both elements are a <code>Just</code>, or a <code>Nothing</code> if any of them (or both) holds no value. In code, that description looks like:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> x y <span class="kw">of</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Just</span> x', <span class="dt">Just</span> y') <span class="ot">-&gt;</span> <span class="dt">Just</span> (x', y')</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  (_,       _)       <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h4 id="exercise-3-4">Exercise 3</h4>
<p>In this solution I am assuming that you implement the <code>State</code> monad using the following data type:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">S</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre></div>
<p>The definitions of <code>get</code>, <code>put</code>, and <code>modify</code> are:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">S</span> (\s <span class="ot">-&gt;</span> (s, s))</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>put newState <span class="ot">=</span> <span class="dt">S</span> (\_ <span class="ot">-&gt;</span> ((), newState))</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- or using modify</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>put newState <span class="ot">=</span> modify (\_ <span class="ot">-&gt;</span> newState)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- other possibility</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>put newState <span class="ot">=</span> modify (<span class="fu">const</span> newState)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>modify f <span class="ot">=</span> <span class="dt">S</span> (\s <span class="ot">-&gt;</span> ((), f s))</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- or using get and put</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>modify f <span class="ot">=</span> <span class="kw">do</span> s <span class="ot">&lt;-</span> get</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>              put (f s)</span></code></pre></div>
<h4 id="exercise-4-3">Exercise 4</h4>
<p>The general type for <code>sequence</code> is <code>Monad m =&gt; [m a] -&gt; m [a]</code>. If we concretize the type to <code>Maybe</code>, we get to <code>[Maybe a] -&gt; Maybe [a]</code>. This already tells us that the final result of a <code>sequence</code> is going to be a list which might be absent.</p>
<p>Let us now look at the definition of <code>sequence</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> []     <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> (r<span class="op">:</span>rs) <span class="ot">=</span> <span class="kw">do</span> x  <span class="ot">&lt;-</span> r</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                     xs <span class="ot">&lt;-</span> <span class="fu">sequence</span> rs</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">return</span> (r<span class="op">:</span>rs)</span></code></pre></div>
<p>At this point we need to remember what the monad instance for <code>Maybe</code> does. If at some point the right-hand side of a <code>&lt;-</code> is <code>Nothing</code>, the entire result becomes <code>Nothing</code>. Following this reasoning, <code>sequence ms</code> returns a <code>Just</code> only when <em>every</em> element in the list <code>ms</code> is a <code>Just</code>, and <code>Nothing</code> otherwise.</p>
<h4 id="exercise-5-3">Exercise 5</h4>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m a</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>foldM _ v []     <span class="ot">=</span> <span class="fu">return</span> v</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>foldM f v (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">do</span> w <span class="ot">&lt;-</span> f v x</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                      foldM f w xs</span></code></pre></div>
<h4 id="exercise-7-1">Exercise 7</h4>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="ot">=</span> <span class="dt">Var</span> a <span class="op">|</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- return :: a -&gt; Expr a</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">Var</span> x</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (&gt;&gt;=) :: Expr a -&gt; (a -&gt; Expr b) -&gt; Expr b</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Var</span> a)   <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Val</span> n)   <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Val</span> n</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Add</span> x y) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Add</span> (x <span class="op">&gt;&gt;=</span> f) (y <span class="op">&gt;&gt;=</span> f)</span></code></pre></div>
<p>This binding operation performs <em>substitution</em>. That is, if we have an expression <code>x</code> and a function <code>f</code> which maps those variables to further expressions, then <code>x &gt;&gt;= f</code> is the result of applying that map to <code>x</code>.</p>
    </div>
  </body>
</html>
